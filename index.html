<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Extraction DIM (OCR autonome) - V1</title>

  <style>
    body{font-family:Arial, sans-serif; margin:20px; max-width:1100px}
    h2{margin:0 0 6px 0}
    .small{font-size:12px; color:#444}
    .card{border:1px solid #ddd; border-radius:10px; padding:14px; background:#fff; box-shadow:0 1px 2px rgba(0,0,0,0.04)}
    .cardHeader{display:flex; align-items:center; justify-content:space-between; gap:12px; flex-wrap:wrap}
    .cardTitle{font-weight:bold; font-size:16px}
    .controls{display:flex; gap:10px; flex-wrap:wrap; align-items:center}
    label{font-weight:bold}
    input[type="file"]{padding:6px}
    input[type="number"]{width:90px; padding:6px}
    button{padding:10px 14px; cursor:pointer}
    button:disabled{opacity:0.5; cursor:not-allowed}
    .status{margin-top:10px; font-weight:bold}
    .ok{color:#1b5e20}
    .err{color:#b00020}
    .muted{color:#666; font-size:12px}
    .spacer{height:10px}
    .tools{display:flex; gap:10px; flex-wrap:wrap; align-items:center}
    .grid{display:grid; grid-template-columns: 220px 1fr 110px; gap:10px; align-items:center; margin-top:10px}
    .fieldLabel{font-weight:bold}
    .fieldVal{width:100%; padding:8px; box-sizing:border-box}
    .btnCopy{padding:8px 10px}
    .btnSel{padding:8px 10px}
    details{margin-top:10px}
    summary{cursor:pointer; font-weight:bold}
    .mono{font-family:Consolas, monospace; font-size:12px; white-space:pre-wrap}
    .pill{display:inline-block; padding:4px 10px; border-radius:999px; font-size:12px; font-weight:bold}
    .pillOk{background:#e7f4ea; color:#1b5e20; border:1px solid #b8e0c1}
    .pillWarn{background:#fff4e5; color:#8a4b00; border:1px solid #ffd29a}
    .pillBad{background:#fde8ea; color:#b00020; border:1px solid #f5b3bb}
  </style>

  <!-- PDF.js (render pages) -->
  <!-- on chargera pdf.mjs dans le code ailleurs, via import dynamique -->

  <!-- Tesseract.js (OCR local) -->
  <script src="./libs/tesseract/tesseract.min.js"></script>

  <!-- Proj4js (Lambert II étendu -> WGS84) -->
  <script src="./libs/proj4/proj4.min.js"></script>
</head>

<body>
  <h2>Extraction DIM (OCR autonome) - V1</h2>
  <div class="small">
    Déposez un PDF DIM (même scanné). L’OCR est limité à 20 pages. Les champs extraits sont regroupés par blocs, avec un bouton « Copier » pour chaque valeur.
  </div>

  <div class="card" style="margin-top:14px;">
    <div class="cardHeader">
      <div class="cardTitle">Entrée PDF</div>
      <div class="controls">
        <label for="pdfFile">PDF DIM</label>
        <input id="pdfFile" type="file" accept="application/pdf" />
        <label for="maxPages">Pages max</label>
        <input id="maxPages" type="number" min="1" max="20" value="10" />
        <button id="btnAnalyze" type="button">Analyser</button>
        <button id="btnClear" type="button">Effacer</button>
      </div>
    </div>
    <div id="status" class="status muted">Prêt.</div>
    <div id="progress" class="muted"></div>
    
    <details style="margin-top:10px;">
    <summary>Debug</summary>
    <div class="mono" id="debugLog"></div>
    </details>

  </div>

  <div class="spacer"></div>

  <!-- Bloc 1 : Document -->
  <div class="card">
    <div class="cardHeader">
      <div class="cardTitle">Bloc 1 - Document DIM</div>
      <div class="tools">
        <button id="selDoc" class="btnSel" type="button">Sélectionner le bloc</button>
      </div>
    </div>

    <div class="grid" id="blockDoc">
      <div class="fieldLabel">Opérateur</div>
      <input id="doc_operator" class="fieldVal" readonly />
      <button id="copy_doc_operator" class="btnCopy" type="button">Copier</button>

      <div class="fieldLabel">Date du document</div>
      <input id="doc_date" class="fieldVal" readonly />
      <button id="copy_doc_date" class="btnCopy" type="button">Copier</button>

      <div class="fieldLabel">Référence du site</div>
      <input id="doc_siteRef" class="fieldVal" readonly />
      <button id="copy_doc_siteRef" class="btnCopy" type="button">Copier</button>
    </div>

    <details>
      <summary>Traçabilité (pages et extraits OCR)</summary>
      <div class="mono" id="traceDoc"></div>
    </details>
  </div>

  <div class="spacer"></div>

  <!-- Bloc 2 : Localisation -->
  <div class="card">
    <div class="cardHeader">
      <div class="cardTitle">Bloc 2 - Localisation du site</div>
      <div class="tools">
        <button id="selLoc" class="btnSel" type="button">Sélectionner le bloc</button>
        <button id="btnOpenCarto" type="button">Ouvrir Cartoradio</button>
      </div>
    </div>

    <div class="grid" id="blockLoc">
      <div class="fieldLabel">Adresse (format Cartoradio)</div>
      <input id="loc_addrCarto" class="fieldVal" readonly />
      <button id="copy_loc_addrCarto" class="btnCopy" type="button">Copier</button>

      <div class="fieldLabel">Commune</div>
      <input id="loc_city" class="fieldVal" readonly />
      <button id="copy_loc_city" class="btnCopy" type="button">Copier</button>

      <div class="fieldLabel">Département</div>
      <input id="loc_dept" class="fieldVal" readonly />
      <button id="copy_loc_dept" class="btnCopy" type="button">Copier</button>

      <div class="fieldLabel">Région</div>
      <input id="loc_region" class="fieldVal" readonly />
      <button id="copy_loc_region" class="btnCopy" type="button">Copier</button>
    </div>

    <details>
      <summary>Traçabilité (pages et extraits OCR)</summary>
      <div class="mono" id="traceLoc"></div>
    </details>
  </div>

  <div class="spacer"></div>

  <!-- Bloc 3 : Coordonnées -->
  <div class="card">
    <div class="cardHeader">
      <div class="cardTitle">Bloc 3 - Coordonnées</div>
      <div class="tools">
        <button id="selCoord" class="btnSel" type="button">Sélectionner le bloc</button>
        <span id="coordPill" class="pill pillWarn" style="display:none;"></span>
      </div>
    </div>

    <div class="grid" id="blockCoord">
      <div class="fieldLabel">X Lambert II étendu (m)</div>
      <input id="coord_x" class="fieldVal" readonly />
      <button id="copy_coord_x" class="btnCopy" type="button">Copier</button>

      <div class="fieldLabel">Y Lambert II étendu (m)</div>
      <input id="coord_y" class="fieldVal" readonly />
      <button id="copy_coord_y" class="btnCopy" type="button">Copier</button>

      <div class="fieldLabel">Latitude WGS84 (deg)</div>
      <input id="coord_lat" class="fieldVal" readonly />
      <button id="copy_coord_lat" class="btnCopy" type="button">Copier</button>

      <div class="fieldLabel">Longitude WGS84 (deg)</div>
      <input id="coord_lon" class="fieldVal" readonly />
      <button id="copy_coord_lon" class="btnCopy" type="button">Copier</button>

      <div class="fieldLabel">Latitude, longitude (°)</div>
      <input id="coord_latlon" class="fieldVal" readonly />
      <button id="copy_coord_latlon" class="btnCopy" type="button">Copier</button>

      <div class="fieldLabel">Longitude, latitude (KML)</div>
      <input id="coord_lonlat" class="fieldVal" readonly />
      <button id="copy_coord_lonlat" class="btnCopy" type="button">Copier</button>

      <div class="fieldLabel">Source des lat/lon</div>
      <input id="coord_src" class="fieldVal" readonly />
      <button id="copy_coord_src" class="btnCopy" type="button">Copier</button>

      <div class="fieldLabel">Cohérence DIM(X,Y,lat,long)</div>

      <input id="coord_delta" class="fieldVal" readonly />
      <button id="copy_coord_delta" class="btnCopy" type="button">Copier</button>
    </div>

    <details>
      <summary>Traçabilité (pages et extraits OCR)</summary>
      <div class="mono" id="traceCoord"></div>
    </details>
  </div>

  <div class="spacer"></div>

  <!-- Bloc 4 : Antennes -->
  <div class="card">
    <div class="cardHeader">
      <div class="cardTitle">Bloc 4 - Antennes</div>
      <div class="tools">
        <button id="selAnt" class="btnSel" type="button">Sélectionner le bloc</button>
      </div>
    </div>

    <div class="grid" id="blockAnt">
      <div class="fieldLabel">Azimuts (°)</div>
      <input id="ant_az_pretty" class="fieldVal" readonly />
      <button id="copy_ant_az_pretty" class="btnCopy" type="button">Copier</button>

      <div class="fieldLabel">Azimuts (format CSV ;)</div>
      <input id="ant_az_csv" class="fieldVal" readonly />
      <button id="copy_ant_az_csv" class="btnCopy" type="button">Copier</button>
    </div>

    <details>
      <summary>Traçabilité (pages et extraits OCR)</summary>
      <div class="mono" id="traceAnt"></div>
    </details>
  </div>

  <div class="spacer"></div>

  <!-- Bloc 5 : Export -->
  <div class="card">
    <div class="cardHeader">
      <div class="cardTitle">Bloc 5 - Export global</div>
      <div class="tools">
        <button id="selAll" class="btnSel" type="button">Sélectionner le résumé</button>
      </div>
    </div>

    <div class="grid" id="blockExport">
      <div class="fieldLabel">Résumé global</div>
      <input id="export_summary" class="fieldVal" readonly />
      <button id="copy_export_summary" class="btnCopy" type="button">Copier</button>

      <div class="fieldLabel">Export JSON (texte)</div>
      <input id="export_json" class="fieldVal" readonly />
      <button id="copy_export_json" class="btnCopy" type="button">Copier</button>
    </div>

    <details>
      <summary>Notes</summary>
      <div class="mono muted" id="notesOcr">
      V1 : extraction champs clés + traçabilité. OCR limité à 20 pages.
      </div>

    </details>
  </div>

<script>

const OCR_MAX_PAGES = 20;

async function ensurePdfJsModule(){
  if (window.pdfjsLib && window.pdfjsLib.getDocument) return window.pdfjsLib;

  const pdfjs = await import("./libs/pdfjs/pdf.mjs");

  // On fabrique un objet pdfjsLib minimal compatible avec ton code existant
  window.pdfjsLib = pdfjs;

  // Worker local en module

window.pdfjsLib.GlobalWorkerOptions.workerPort =
  new Worker("./libs/pdfjs/pdf.worker.mjs", { type: "module" });



  return window.pdfjsLib;
}



"use strict";

window.addEventListener("error", (ev) => {
  try { dbg("JS ERROR: " + (ev.message || ev.error || "Erreur inconnue")); } catch(e) {}
  try { setStatus("Erreur JavaScript : voir Debug.", "err"); } catch(e) {}
});

window.addEventListener("unhandledrejection", (ev) => {
  try { dbg("PROMISE REJECT: " + (ev.reason ? (ev.reason.message || ev.reason) : "rejet")); } catch(e) {}
  try { setStatus("Erreur (Promise) : voir Debug.", "err"); } catch(e) {}
});



/* =========================================================
   Helpers DOM / UI
   ========================================================= */
const $ = (id) => document.getElementById(id);

function setStatus(msg, kind){
  const el = $("status");
  el.className = "status " + (kind === "ok" ? "ok" : (kind === "err" ? "err" : "muted"));
  el.textContent = msg || "";
}

function setProgress(msg){ $("progress").textContent = msg || ""; }

function dbg(msg){
  const el = $("debugLog");
  if (!el) return;
  el.textContent += msg + "\n";
}

function setAnalyzeBusy(isBusy){
  $("btnAnalyze").disabled = !!isBusy;
  $("btnClear").disabled = !!isBusy;
  $("pdfFile").disabled = !!isBusy;
  $("maxPages").disabled = !!isBusy;
}


function setVal(id, v){
  const el = $(id);
  if (!el) return;
  el.value = (v == null) ? "" : String(v);
}
function setText(id, v){
  const el = $(id);
  if (!el) return;
  el.textContent = (v == null) ? "" : String(v);
}

function clearAllFields(){
   setText("debugLog", "");

  [
    "doc_operator","doc_date","doc_siteRef",
    "loc_addrCarto","loc_city","loc_dept","loc_region",
    "coord_x","coord_y","coord_lat","coord_lon","coord_latlon","coord_lonlat","coord_src","coord_delta",
    "ant_az_pretty","ant_az_csv",
    "export_summary","export_json"
  ].forEach(id => setVal(id, ""));

  ["traceDoc","traceLoc","traceCoord","traceAnt"].forEach(id => setText(id, ""));

  $("coordPill").style.display = "none";
  $("coordPill").className = "pill pillWarn";
  $("coordPill").textContent = "";

  setProgress("");
  setStatus("Prêt.", "ok");
}

function dumpFullOcrText(pages){
  return pages
    .map(p => `===== PAGE ${p.page} =====\n${p.text || ""}`)
    .join("\n\n");
}


function selectBlock(blockId){
  const el = $(blockId);
  if (!el) return;

  const text = el.innerText || "";
  const ta = document.createElement("textarea");
  ta.value = text;
  ta.style.position = "fixed";
  ta.style.left = "-9999px";
  ta.style.top = "-9999px";
  document.body.appendChild(ta);
  ta.focus();
  ta.select();
  ta.setSelectionRange(0, ta.value.length);
  document.body.removeChild(ta);

  setStatus("Bloc sélectionné. Faites Ctrl+C.", "ok");
}

/* =========================================================
   Clipboard: copie robuste
   ========================================================= */
async function copyTextRobust(text, selectFallbackEl){
  const t = (text || "").toString();
  if (!t.trim()) return { ok:false, mode:"empty" };

  try {
    if (navigator.clipboard && navigator.clipboard.writeText && window.isSecureContext) {
      await navigator.clipboard.writeText(t);
      return { ok:true, mode:"clipboard" };
    }
  } catch(e){}

  if (selectFallbackEl) {
    selectFallbackEl.focus({preventScroll:true});
    selectFallbackEl.select();
    selectFallbackEl.setSelectionRange(0, selectFallbackEl.value.length);
    return { ok:false, mode:"select" };
  }

  return { ok:false, mode:"fail" };
}

async function copyFieldValue(inputId){
  const el = $(inputId);
  const v = el ? (el.value || "") : "";
  const r = await copyTextRobust(v, el);
  if (r.ok) setStatus("Copié.", "ok");
  else if (r.mode === "select") setStatus("Copie automatique refusée. Valeur sélectionnée : faites Ctrl+C.", "err");
  else setStatus("Rien à copier.", "err");
}

/* =========================================================
   PDF.js configuration
   ========================================================= */
// pdfjsLib.GlobalWorkerOptions.workerSrc =
// "https://cdn.jsdelivr.net/npm/pdfjs-dist@4.10.38/build/pdf.worker.min.js";

/* =========================================================
   Projections : Lambert II étendu (EPSG:27572) -> WGS84 (EPSG:4326)
   ========================================================= */
 //proj4.defs("EPSG:27572",
 // "+proj=lcc +lat_1=46.8 +lat_2=45.89891888888889 +lat_0=46.8 " +
 // "+lon_0=0 +x_0=600000 +y_0=2200000 +a=6378249.2 +b=6356515 " +
 // "+towgs84=-168,-60,320,0,0,0,0 +units=m +no_defs");

let _projInited = false;


window._projInited = window._projInited || false;
if (!window._projInited) {
proj4.defs("EPSG:27572",
  "+proj=lcc +lat_1=46.8 +lat_2=45.89891888888889 +lat_0=46.8 " +
  "+lon_0=0 +x_0=600000 +y_0=2200000 +a=6378249.2 +b=6356515 " +
  "+pm=paris " +
  "+towgs84=-168,-60,320,0,0,0,0 +units=m +no_defs"
);

  window._projInited = true;
}



/* =========================================================
   OCR + parsing
   ========================================================= */

function normSpaces(s){ return (s || "").toString().replace(/\s+/g, " ").trim(); }

function normalizeOcrText(s){
  let t = (s || "").toString();

  // uniformiser espaces
  t = t.replace(/\r/g, "\n");
  t = t.replace(/[ \t]+/g, " ");
  t = t.replace(/\n{3,}/g, "\n\n");

  // symboles degré
  t = t.replace(/º/g, "°");

  // OCR fréquents: 0/O dans les nombres -> correction prudente
  // remplace O par 0 seulement dans des tokens très numériques
  t = t.replace(/([0-9])O(?=[0-9])/g, "$10");
  t = t.replace(/O(?=[0-9])/g, "0");
    // OCR fréquent : "6O°" au lieu de "60°"
  t = t.replace(/([0-9])O(?=°)/g, "$10");
  t = t.replace(/O(?=°)/g, "0");
  

  return t;
}

function findFirstRegex(pages, re){
  for (const p of pages) {
    const m = p.text.match(re);
    if (m) return { page:p.page, match:m };
  }
  return null;
}

function findAllRegex(pages, re){
  const out = [];
  for (const p of pages) {
    let m;
    const r = new RegExp(re.source, re.flags.includes("g") ? re.flags : (re.flags + "g"));
    while ((m = r.exec(p.text)) !== null) {
      out.push({ page:p.page, match:m });
      if (m.index === r.lastIndex) r.lastIndex++;
    }
  }
  return out;
}

function joinedText(pages){
  return pages.map(p => p.text || "").join("\n");
}

function extractOperator(pages){
  function joinFirstN(pgs, n){
    const arr = [];
    const k = Math.min(n, pgs.length);
for (let i = 0; i < k; i++){
  arr.push(String((pgs[i] && pgs[i].text) ? pgs[i].text : ""));
}

    return arr.join("\n");
  }

  function countMatches(text, rx){
    const m = text.match(rx);
    return m ? m.length : 0;
  }

  function proximityBonus(text, opWord){
    // bonus si "projet" ou "operateur/opérateur" est à <= 5 mots de l'opérateur (avant ou après)
    // On travaille en "mots" : \S+ (simple, efficace en OCR)
    // Exemple : "Adresse du projet SFR" / "Opérateur : SFR"
    const ctx = [
      new RegExp(`\\bprojet\\b(?:\\s+\\S+){0,5}\\s+\\b${opWord}\\b`, "i"),
      new RegExp(`\\b${opWord}\\b(?:\\s+\\S+){0,5}\\s+\\bprojet\\b`, "i"),
      new RegExp(`\\bop[ée]rateur\\b(?:\\s+\\S+){0,5}\\s+\\b${opWord}\\b`, "i"),
      new RegExp(`\\b${opWord}\\b(?:\\s+\\S+){0,5}\\s+\\bop[ée]rateur\\b`, "i")
    ];
    let bonus = 0;
    for (let i = 0; i < ctx.length; i++){
      if (ctx[i].test(text)) bonus += 5; // bonus par motif trouvé
    }
    return bonus;
  }

  const tAll = joinedText(pages);
  const tFirst5 = joinFirstN(pages, 5);

  // 1) Extraction explicite "Opérateur : XXX" si présente (très fiable)
  const m = tAll.match(/\bop[ée]rateur\b\s*[:\-]\s*([^\n]+)/i);
  if (m) return { value: normSpaces(m[1]).toUpperCase(), page: null, snippet: m[0] };

  // 2) Vote global + bonus de proximité
  const ops = [
    { label: "SFR", word: "sfr", rx: /\bsfr\b/gi },
    { label: "ORANGE", word: "orange", rx: /\borange\b/gi },
    { label: "FREE MOBILE", word: "free", rx: /\bfree\b/gi },
    { label: "BOUYGUES TELECOM", word: "bouygues", rx: /\bbouygues\b/gi }
  ];

  const scoresAll = [];
  for (let i = 0; i < ops.length; i++){
    const base = countMatches(tAll, ops[i].rx);
    const bonus = proximityBonus(tAll, ops[i].word);
    scoresAll.push({ i: i, label: ops[i].label, score: base + bonus, base: base, bonus: bonus });
  }

  // meilleur score global
  let best = scoresAll[0];
  for (let i = 1; i < scoresAll.length; i++){
    if (scoresAll[i].score > best.score) best = scoresAll[i];
  }

  // vérifier égalité sur score global
  let tied = [];
  for (let i = 0; i < scoresAll.length; i++){
    if (scoresAll[i].score === best.score && best.score > 0) tied.push(scoresAll[i]);
  }

  // 3) Si égalité, départage sur les 5 premières pages (avec bonus aussi)
  if (tied.length > 1){
    let best5 = tied[0];
    for (let k = 0; k < tied.length; k++){
      const op = ops[tied[k].i];
      const base5 = countMatches(tFirst5, op.rx);
      const bonus5 = proximityBonus(tFirst5, op.word);
      const score5 = base5 + bonus5;

      if (k === 0){
        best5 = { i: tied[k].i, label: tied[k].label, score5: score5, base5: base5, bonus5: bonus5 };
      } else if (score5 > best5.score5){
        best5 = { i: tied[k].i, label: tied[k].label, score5: score5, base5: base5, bonus5: bonus5 };
      }
    }

    if (best5.score5 > 0){
      return {
        value: best5.label,
        page: null,
        snippet: `tie-break first5: ${best5.label} (base=${best5.base5}, bonus=${best5.bonus5})`
      };
    }
  }

  // 4) Si un score global existe, on renvoie
  if (best.score > 0){
    return {
      value: best.label,
      page: null,
      snippet: `global: ${best.label} (base=${best.base}, bonus=${best.bonus})`
    };
  }

  return { value:"", page:null, snippet:"" };
}


function extractDate(pages, fileName){
  const t = joinedText(pages);

  // 1) Date numérique : 29/08/2023 (ou 29-08-2023)
  const m0 = t.match(/\bdate\b\s*[:\-]\s*(\d{1,2}[\/\-.]\d{1,2}[\/\-.]\d{2,4})/i);
  if (m0) return { value: m0[1], page:null, snippet:m0[0] };

  const m1 = t.match(/(\d{1,2}[\/\-.]\d{1,2}[\/\-.]\d{2,4})/);
  if (m1) return { value: m1[1], page:null, snippet:m1[0] };

  // 2) Date FR : "30 juin 2016"
  const months = "(janvier|fevrier|février|mars|avril|mai|juin|juillet|aout|août|septembre|octobre|novembre|decembre|décembre)";
  const reDayMonthYear = new RegExp("\\b(\\d{1,2})\\s+" + months + "\\s+(\\d{4})\\b", "i");
  const m2 = t.match(reDayMonthYear);
  if (m2) return { value: m2[1] + " " + m2[2] + " " + m2[3], page:null, snippet:m2[0] };

  // 3) Mois + année : "novembre 2017" (ou "octobre-novembre 2017")
  const reMonthYear = new RegExp("\\b" + months + "(?:\\s*[-/]+\\s*" + months + ")?\\s+(\\d{4})\\b", "i");
  const m3 = t.match(reMonthYear);
  if (m3){
    // si c'est "octobre-novembre 2017", m3[0] contient tout
    return { value: m3[0], page:null, snippet:m3[0] };
  }

  // 4) Fallback : nom de fichier (ex: "...-07-2017.pdf" ou "..._07-2017.pdf")
  const fn = (fileName || "").toString();
  const mf = fn.match(/(?:^|[^0-9])(\d{2})[\/\-. _](\d{4})(?:[^0-9]|$)/);
  if (mf){
    const mm = mf[1];
    const yyyy = mf[2];
    return { value: mm + "/" + yyyy, page:null, snippet:"filename: " + fn };
  }

  return { value:"", page:null, snippet:"" };
}


function extractSiteRef(pages){

  // 0) Cas SFR explicite : "Référence SFR :" puis valeur parfois sur la ligne suivante
  const hitSfrRef = findFirstRegex(
    pages,
    /\br[ée]f[ée]rence\s*sfr\b\s*[:\-]?\s*(?:\n\s*)?(N[°o]\s*G2R\s*\d{6,}[^\n]*)/i
  );
  if (hitSfrRef) {
    return {
      value: normSpaces(hitSfrRef.match[1]),
      page: hitSfrRef.page,
      snippet: hitSfrRef.match[0]
    };
  }

  // 1) Cas générique "Code site :", "Code du site :"
  const hitCodeSite = findFirstRegex(
    pages,
    /\bcode\s*(?:du\s*)?site\b\s*[:\-]\s*([A-Z0-9][A-Z0-9\-_/]{6,})/i
  );
  if (hitCodeSite) {
    return {
      value: normSpaces(hitCodeSite.match[1]),
      page: hitCodeSite.page,
      snippet: hitCodeSite.match[0]
    };
  }

  // 2) Cas "N° ..." (ANFR, G2R, interne opérateur), avec label
  const hitNumero = findFirstRegex(
    pages,
    /\bN[°o]\s*(?:ANFR|G2R)?\s*[:\-]?\s*([A-Z0-9]{6,}[A-Z0-9\-_/ ]*)/i
  );
  if (hitNumero) {
    return {
      value: normSpaces(hitNumero.match[1]),
      page: hitNumero.page,
      snippet: hitNumero.match[0]
    };
  }

  // 3) Fallback global : identifiant structuré fréquent dans les DIM
  const t = joinedText(pages);
  const m1 = t.match(/\b[A-Z0-9]{6,}(?:[-_\/]\d+|\s+\d{6,})\b/);
  if (m1) {
    return {
      value: normSpaces(m1[0]),
      page: null,
      snippet: m1[0]
    };
  }

  // 4) Rien trouvé
  return { value:"", page:null, snippet:"" };
}



function extractAddressLine(pages){
  function joinFirstN(pgs, n){
    const arr = [];
    const k = Math.min(n, pgs.length);
    for (let i = 0; i < k; i++) arr.push(String((pgs[i] && pgs[i].text) ? pgs[i].text : ""));

    return arr.join("\n");
  }

  const tAll = joinedText(pages);
  const t5 = joinFirstN(pages, 5);

  // Types de voie (pour éviter de capturer des lignes "Commune : 35000 RENNES" ou des faux positifs)
  const rxVoie = /\b(rue|avenue|av\.|boulevard|bd|bld|chemin|impasse|place|route|all[ée]e|quai|cours|square|passage|sentier|voie)\b/i;

  // 1) Adresse du projet / site (prioritaire) : accepte que ":" soit sur la ligne suivante
  // Exemples gérés :
  // "Adresse du projet SFR : 1, rue Jules Lebrun"
  // "Adresse du site : ..."
  // "Adresse du projet SFR\n: 1, rue ..."
  const m0 = t5.match(
    /\badresse\s+du\s+(?:projet|site)\b[^\n:]{0,60}\s*(?:[:\-]\s*|\n\s*[:\-]\s*)([^\n]+)/i
  );
  if (m0){
    const v = normSpaces(m0[1]);
    if (rxVoie.test(v)) return { value: v, page: null, snippet: m0[0] };
    // Même si l'OCR a mangé "rue/avenue", on retourne quand même car c'est un label "Adresse du projet"
    return { value: v, page: null, snippet: m0[0] };
  }

  // 2) Variante : "Adresse du projet SFR" peut être OCRisée sans "du"
  const m0b = t5.match(
    /\badresse\s+(?:projet|site)\b[^\n:]{0,60}\s*(?:[:\-]\s*|\n\s*[:\-]\s*)([^\n]+)/i
  );
  if (m0b){
    const v = normSpaces(m0b[1]);
    return { value: v, page: null, snippet: m0b[0] };
  }

    // 2bis) Cas Orange : "Adresse du site" (souvent sans ":" et avec "Nom du site" / "Code du site" sur les mêmes lignes)
  const mSite = tAll.match(
    /\badresse\s+du\s+site\b[\s\S]{0,120}?\n\s*([^\n]+?)\s+(?:nom\s+du\s+site|nos\s+r[ée]f[ée]rences)\b[\s\S]{0,120}?\n\s*(\d{5}\s+[A-ZÀ-ÖØ-Ýa-zà-öø-ÿ'\- ]{3,})(?:\s+\bcode\s+du\s+site\b|[^\n]*)/i
  );
  if (mSite){
    const v = normSpaces((mSite[1] + " " + mSite[2]).replace(/\b(code\s+du\s+site|nom\s+du\s+site|nos\s+r[ée]f[ée]rences)\b[\s\S]*$/i, "").trim());

    return { value: v, page: null, snippet: "Adresse du site (bloc dédié)" };
  }

  // 3) Fallback contrôlé : on ne cherche QUE dans les 5 premières pages
  // et on exige un type de voie sur la même ligne
  const lines = t5.split(/\r?\n/);
  for (let i = 0; i < lines.length; i++){
    const line = normSpaces(lines[i]);
        // Exclure les pieds de page / en-têtes qui polluent l'adresse
    if (/^page\s*\d+\b/i.test(line)) continue;
    if (/\bdossier\s+d'information\b/i.test(line)) continue;

    if (!line) continue;

    // Exclusions typiques contact / siège
    if (/\b(bp|cedex|direction|responsable|t[ée]l|mail|@)\b/i.test(line)) continue;

    // On exige une voie (rue/avenue/etc.) pour être une adresse plausible
    if (!rxVoie.test(line)) continue;

    // Cas où CP + ville sont sur la même ligne (parfois)
    const m1 = line.match(/(\d{1,4}\s+.+\s+\b\d{5}\b\s+[A-ZÀ-ÖØ-Ýa-zà-öø-ÿ'\- ]{3,})/);
    if (m1) return { value: normSpaces(m1[1]), page: null, snippet: line };

    // Cas où l'adresse ligne est seule (sans CP/ville), on la garde quand même
    const m2 = line.match(/(\d{1,4}\s+.+)/);
    if (m2) return { value: normSpaces(m2[1]), page: null, snippet: line };
  }

  // 4) Ultime secours (sur tout le doc) : uniquement si on trouve un libellé "Adresse du projet/site"
  // (ça évite de ramasser une adresse de contact plus loin)
  const mLast = tAll.match(
    /\badresse\s+du\s+(?:projet|site)\b[^\n:]{0,60}\s*(?:[:\-]\s*|\n\s*[:\-]\s*)([^\n]+)/i
  );
  if (mLast) return { value: normSpaces(mLast[1]), page: null, snippet: mLast[0] };

  return { value:"", page:null, snippet:"" };
}


function extractCommune(pages){

  // 1) Cas standard : "Commune : 35830 BETTON" ou "Commune de : 35830 BETTON"
  const hit = findFirstRegex(
    pages,
    /\bcommune\b\s*(?:de\s*)?[:\-]\s*(\d{5})\s+([A-ZÀ-ÖØ-Ýa-zà-öø-ÿ'\- ]{2,})/i
  );
  if (hit) {
    return {
      city: normSpaces(hit.match[2]),
      cp: hit.match[1],
      page: hit.page,
      snippet: hit.match[0]
    };
  }

  // 2) Variante sans code postal : "Commune : BETTON"
  const hit2 = findFirstRegex(
    pages,
    /\bcommune\b\s*(?:de\s*)?[:\-]\s*([A-ZÀ-ÖØ-Ýa-zà-öø-ÿ'\- ]{2,})/i
  );
  if (hit2) {
    const v = normSpaces(hit2.match[1]);
    return {
      city: v,
      cp: "",
      page: hit2.page,
      snippet: hit2.match[0]
    };
  }

  // 3) Fallback contrôlé : "Adresse du site : ... 93130 NOISY-LE-SEC"
  // (uniquement si commune absente)
  const hit3 = findFirstRegex(
    pages,
    /\b(\d{5})\s+([A-ZÀ-ÖØ-Ýa-zà-öø-ÿ'\- ]{3,})\b/
  );
  if (hit3) {
    return {
      city: normSpaces(hit3.match[2]),
      cp: hit3.match[1],
      page: hit3.page,
      snippet: hit3.match[0]
    };
  }

  // 4) Rien trouvé
  return { city:"", cp:"", page:null, snippet:"" };
}


function deptFromCP(cp){
  const s = (cp || "").toString().trim();
  if (/^(97|98)\d{3}$/.test(s)) return s.slice(0,3); // DOM-TOM
  if (/^\d{5}$/.test(s)) return s.slice(0,2);       // métropole
  return "";
}



function parseNumberLoose(s){
  if (!s) return NaN;
  let t = s.toString();
  t = t.replace(/\s+/g, "");
  t = t.replace(",", ".");
  // garder digits + dot + minus
  t = t.replace(/[^0-9.\-]/g, "");
  const n = Number(t);
  return Number.isFinite(n) ? n : NaN;
}

function extractLambertXY(pages){

  function parseLambertHeuristic(raw, axis){
    if (!raw) return NaN;

    // Nettoyage minimal OCR : O->0, espaces, virgule->point
    const s = String(raw).replace(/O/g, "0").replace(/\s+/g, "");
    let v = parseNumberLoose(s);

    if (!Number.isFinite(v)) return NaN;

    // Plages plausibles (Lambert II étendu / Lambert 93 proches) : on reste large
    // Ici tu utilises ensuite ton test okX/okY, donc on ne "valide" pas ici, on corrige juste si c'est absurde.
    function inRangeX(x){ return x > 0 && x < 1300000; }
    function inRangeY(y){ return y > 1500000 && y < 3000000; }

    const ok = (axis === "x") ? inRangeX(v) : inRangeY(v);
    if (ok) return v;

    // Heuristique décimale perdue : si entier trop grand, on tente /10, /100, /1000
    // (cas typique : 3049624 -> 304962.4)
    if (Number.isFinite(v) && Math.floor(v) === v){
      const tries = [10, 100, 1000];
      for (let i = 0; i < tries.length; i++){
        const vv = v / tries[i];
        const ok2 = (axis === "x") ? inRangeX(vv) : inRangeY(vv);
        if (ok2) return vv;
      }
    }

    return v; // on retourne la valeur brute (sera filtrée plus bas)
  }

  /* ================================
     PASSE 1 : extraction X/Y dans le même bloc Lambert
     - gère le cas OCR : "-:2361563.69" (Y sans label)
     ================================ */
  for (const p of pages){
    const txt = String(p.text || "");

    // On prend une "bulle" autour du mot Lambert pour éviter de ramasser des X/Y ailleurs
    const mLam = txt.match(/.{0,120}lambert.{0,800}/is);
    const zone = mLam ? mLam[0] : "";

    if (zone){
      // X : "X: 3049624" ou "-X: 3049624"
      const mx = zone.match(/(?:\bX\b|-\s*X)\s*[:=]\s*([0-9O][0-9O\s]*[0-9O](?:[.,]\d{1,3})?)/i);

      // Y : "Y: 2361563.69" ou "-Y: ..." ou (cas OCR) "-:2361563.69"
      const my = zone.match(/(?:\bY\b|-\s*Y)\s*[:=]\s*([0-9O][0-9O\s]*[0-9O](?:[.,]\d{1,3})?)/i)
              || zone.match(/-\s*[:=]\s*([0-9O][0-9O\s]*[0-9O](?:[.,]\d{1,3})?)/i);

      if (mx && my){
        let x = parseLambertHeuristic(mx[1], "x");
        let y = parseLambertHeuristic(my[1], "y");

        // Plausibilité Lambert II étendu (mètres)
        const okX = Number.isFinite(x) && x > 0 && x < 1300000;
        const okY = Number.isFinite(y) && y > 1500000 && y < 3000000;

        return {
          x: okX ? x : NaN,
          y: okY ? y : NaN,
          pageX: p.page,
          pageY: p.page,
          snipX: mx[0],
          snipY: my[0],
          rawX: mx[1],
          rawY: my[1]
        };
      }
    }
  }

  /* ================================
     PASSE 2 : fallback (ton approche initiale)
     ================================ */

  const hitX = findFirstRegex(
    pages,
    /(?:\bX\b|-\s*X)\s*[:=]\s*([0-9O][0-9O\s]*[0-9O](?:[.,]\d{1,3})?)\s*(k?m)?/i
  );
  const hitY = findFirstRegex(
    pages,
    /(?:\bY\b|-\s*Y)\s*[:=]\s*([0-9O][0-9O\s]*[0-9O](?:[.,]\d{1,3})?)\s*(k?m)?/i
  );

  let x = hitX ? parseLambertHeuristic(hitX.match[1], "x") : NaN;
  let y = hitY ? parseLambertHeuristic(hitY.match[1], "y") : NaN;

  const unitX = hitX && hitX.match[2] ? hitX.match[2].toLowerCase() : "";
  const unitY = hitY && hitY.match[2] ? hitY.match[2].toLowerCase() : "";

  if (Number.isFinite(x) && unitX === "km") x = x * 1000;
  if (Number.isFinite(y) && unitY === "km") y = y * 1000;

  const okX = Number.isFinite(x) && x > 0 && x < 1300000;
  const okY = Number.isFinite(y) && y > 1500000 && y < 3000000;

  return {
    x: okX ? x : NaN,
    y: okY ? y : NaN,
    pageX: hitX ? hitX.page : null,
    pageY: hitY ? hitY.page : null,
    snipX: hitX ? hitX.match[0] : "",
    snipY: hitY ? hitY.match[0] : "",
    rawX: hitX ? hitX.match[1] + (hitX.match[2] ? " " + hitX.match[2] : "") : "",
    rawY: hitY ? hitY.match[1] + (hitY.match[2] ? " " + hitY.match[2] : "") : ""
  };
}



function extractLatLonWGS(pages){
  // tolère virgule ou point, "Latitude : 50.57"
  const hitLat = findFirstRegex(pages, /(?:latitude)\s*[:=]\s*([0-9]{1,2}[.,][0-9]{3,})/i);
  const hitLon = findFirstRegex(pages, /(?:longitude)\s*[:=]\s*([0-9]{1,3}[.,][0-9]{3,})/i);

  const lat = hitLat ? parseNumberLoose(hitLat.match[1]) : NaN;
  const lon = hitLon ? parseNumberLoose(hitLon.match[1]) : NaN;

  const okLat = Number.isFinite(lat) && lat > 40 && lat < 52;
  const okLon = Number.isFinite(lon) && lon > -6 && lon < 10;

  return {
    lat: okLat ? lat : NaN,
    lon: okLon ? lon : NaN,
    pageLat: hitLat ? hitLat.page : null,
    pageLon: hitLon ? hitLon.page : null,
    snipLat: hitLat ? hitLat.match[0] : "",
    snipLon: hitLon ? hitLon.match[0] : ""
  };
}

function lambertToWgs84(x, y){
  // proj4 renvoie [lon,lat]
  const out = proj4("EPSG:27572", "EPSG:4326", [x, y]);
  return { lon: out[0], lat: out[1] };
}

function haversineMeters(lat1, lon1, lat2, lon2){
  const R = 6371000.0;
  const toRad = d => d * Math.PI / 180.0;
  const p1 = toRad(lat1), p2 = toRad(lat2);
  const dp = toRad(lat2 - lat1);
  const dl = toRad(lon2 - lon1);
  const a = Math.sin(dp/2)**2 + Math.cos(p1)*Math.cos(p2)*Math.sin(dl/2)**2;
  return 2*R*Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
}

function extractAzimuts(pages){

  /* ================================
     Paramètres
     ================================ */

  const KEYWORDS_RE = /\b(azimut|azimuts|az\b|secteur|s1|s2|s3|s\d[a-z]\d)\b/i;

  const DEGREE_RE   = /(\d{1,3})\s*[°"*]/g;

  const MIN_DIST = 80;     // séparation circulaire min
  const MAX_DIGITS = 3;

  function norm(s){
    return (s || "")
      .replace(/º/g, "°")
      .replace(/[oO]/g, "0")
      .replace(/\s+/g, " ")
      .trim();
  }

  function circDist(a,b){
    const d = Math.abs(a-b) % 360;
    return Math.min(d, 360-d);
  }

  function validAngle(v){
    return Number.isInteger(v) && v >= 0 && v <= 359;
  }

  function validTriplet(a,b,c){
    if (a === b || a === c || b === c) return false;
    if (!validAngle(a) || !validAngle(b) || !validAngle(c)) return false;
    if (circDist(a,b) < MIN_DIST) return false;
    if (circDist(a,c) < MIN_DIST) return false;
    if (circDist(b,c) < MIN_DIST) return false;
    return true;
  }

  /* ================================
     PASSE 1 : triplets compacts
     ================================ */
  const found = [];

  for (const p of pages){
    const lines = norm(p.text).split("\n").map(l => l.trim());

    for (let i=0;i<lines.length;i++){
      const line = lines[i];
      if (!line || !KEYWORDS_RE.test(line)) continue;

      // bulle locale (ligne seule + voisins)
      const bubble = [
        lines[i-1] || "",
        lines[i]   || "",
        lines[i+1] || ""
      ].join(" ");

      const angles = [];
      let m;
      DEGREE_RE.lastIndex = 0;
      while ((m = DEGREE_RE.exec(bubble)) !== null){
        if (m[1].length > MAX_DIGITS) continue;
        const v = Number(m[1]);
        if (validAngle(v)) angles.push(v);
      }

      const uniq = [...new Set(angles)];

      if (uniq.length >= 3){
        for (let a=0;a<uniq.length;a++){
          for (let b=a+1;b<uniq.length;b++){
            for (let c=b+1;c<uniq.length;c++){
              if (validTriplet(uniq[a],uniq[b],uniq[c])){
                found.push({
                  tri: [uniq[a],uniq[b],uniq[c]].sort((x,y)=>x-y),
                  page: p.page,
                  source: "compact",
                  context: bubble
                });
              }
            }
          }
        }
      }
    }
  }

  if (found.length){
    const best = found[0];
    return {
      list: best.tri,
      trace: `p.${best.page}: ${best.tri.join("° / ")}°\nsource=${best.source}`
    };
  }

  /* ================================
     PASSE 2 : fallback lignes simples
     ================================ */
  const singles = [];

  for (const p of pages){
    const lines = norm(p.text).split("\n").map(l => l.trim());

    for (let i=0;i<lines.length;i++){
      const L0 = lines[i]   || "";
      const L1 = lines[i-1] || "";
      const L2 = lines[i+1] || "";

      const hasKey =
        KEYWORDS_RE.test(L0) ||
        KEYWORDS_RE.test(L1) ||
        KEYWORDS_RE.test(L2);

      if (!hasKey) continue;

      const zone = [L1,L0,L2].join(" ");

      let m;
      DEGREE_RE.lastIndex = 0;
      while ((m = DEGREE_RE.exec(zone)) !== null){
        if (m[1].length > MAX_DIGITS) continue;
        const v = Number(m[1]);
        if (!validAngle(v)) continue;

        singles.push({
          v,
          page: p.page,
          context: zone
        });
      }
    }
  }

  // dédup
  const uniqVals = [];
  for (const s of singles){
    if (!uniqVals.some(u => u.v === s.v)) uniqVals.push(s);
  }

  // assemblage triplet
  for (let a=0;a<uniqVals.length;a++){
    for (let b=a+1;b<uniqVals.length;b++){
      for (let c=b+1;c<uniqVals.length;c++){
        const A = uniqVals[a].v;
        const B = uniqVals[b].v;
        const C = uniqVals[c].v;

        if (validTriplet(A,B,C)){
          const tri = [A,B,C].sort((x,y)=>x-y);
          return {
            list: tri,
            trace:
              `fallback lignes simples\n` +
              `p.${uniqVals[a].page}/${uniqVals[b].page}/${uniqVals[c].page}: ` +
              `${tri.join("° / ")}°`
          };
        }
      }
    }
  }

  return { list: [], trace: "" };
}





/* =========================================================
   BAN (France) : compléter localisation à partir de lat/lon ou adresse
   ========================================================= */
async function banReverse(lat, lon){
  const url = "https://api-adresse.data.gouv.fr/reverse/?" +
              "lat=" + encodeURIComponent(lat) +
              "&lon=" + encodeURIComponent(lon) +
              "&limit=1";
  const r = await fetch(url, { headers: { "Accept":"application/json" } });
  if (!r.ok) throw new Error("BAN reverse HTTP " + r.status);
  return await r.json();
}

async function banSearch(address){
  const url = "https://api-adresse.data.gouv.fr/search/?" +
              "q=" + encodeURIComponent(address) +
              "&limit=1";
  const r = await fetch(url, { headers: { "Accept":"application/json" } });
  if (!r.ok) throw new Error("BAN search HTTP " + r.status);
  return await r.json();
}

function parseContextDeptRegion(contextStr){
  // ex: "59, Nord, Hauts-de-France"
  const parts = (contextStr || "").toString().split(",").map(s => s.trim()).filter(Boolean);
  const dept = parts[1] ? parts[1] : (parts[0] ? parts[0] : "");
  const region = parts[2] ? parts[2] : "";
  return { dept, region };
}

function buildCartoradioAddressFromBAN(props){
  const num = props.housenumber || "";
  const street = props.street || props.name || "";
  const cp = props.postcode || "";
  const city = props.city || "";
  return normSpaces((num ? (num + " ") : "") + street + (cp ? (" " + cp) : "") + (city ? (" " + city) : ""));
}

/* =========================================================
   OCR execution
   ========================================================= */

async function renderPdfPageToCanvas(pdf, pageNumber, scale){
  const page = await pdf.getPage(pageNumber);
  const viewport = page.getViewport({ scale });
  const canvas = document.createElement("canvas");
  const ctx = canvas.getContext("2d", { willReadFrequently: true });
  canvas.width = Math.floor(viewport.width);
  canvas.height = Math.floor(viewport.height);

  await page.render({ canvasContext: ctx, viewport }).promise;
  return canvas;
}


function ocrLogger(m){
  try{
    if (m && m.status === "recognizing text" && typeof m.progress === "number"){
      setProgress("OCR en cours... " + Math.round(100*m.progress) + " %");
    }
  } catch(e){}
}


async function runOcrOnPdf(arrayBuffer, maxPages){
  const loadingTask = pdfjsLib.getDocument({ data: new Uint8Array(arrayBuffer) });

  const pdf = await loadingTask.promise;

  const total = Math.min(pdf.numPages, Math.max(1, Math.min(OCR_MAX_PAGES, maxPages)));
  setProgress("PDF chargé : " + pdf.numPages + " page(s). OCR sur " + total + " page(s).");

const worker = await Tesseract.createWorker(
  "fra",
  1,
  {
    workerPath: "./libs/tesseract/worker.min.js",
    corePath: "./libs/tesseract/tesseract-core.wasm.js",
    langPath: "./libs/tessdata"
  }
);

// Important : STRING, pas tableau
await worker.loadLanguage("fra");
await worker.initialize("fra");


  const pages = [];
  for (let i = 1; i <= total; i++) {
    setStatus("OCR en cours...", "ok");
    setProgress("Page " + i + " / " + total + " : rendu + OCR...");

    dbg("Page " + i + ": rendu");

    // scale : compromis vitesse/qualité
    const canvas = await renderPdfPageToCanvas(pdf, i, 2.0);

    // OCR
    dbg("Page " + i + ": OCR");

    const { data } = await worker.recognize(canvas);

  
    const text = normalizeOcrText(data && data.text ? data.text : "");
    pages.push({ page:i, text:text });

    // libérer
    canvas.width = 1;
    canvas.height = 1;
  }

  await worker.terminate();
  setProgress("OCR terminé sur " + total + " page(s).");
  return pages;
}

/* =========================================================
   Parsing global -> remplir UI
   ========================================================= */
function pillCoord(kind, msg){
  const el = $("coordPill");
  el.style.display = "inline-block";
  el.className = "pill " + (kind === "ok" ? "pillOk" : (kind === "bad" ? "pillBad" : "pillWarn"));
  el.textContent = msg;
}

function buildSummary(data){
  const lines = [];
  lines.push("Opérateur: " + (data.operator || ""));
  lines.push("Date: " + (data.date || ""));
  lines.push("Référence site: " + (data.siteRef || ""));
  lines.push("Adresse Cartoradio: " + (data.addrCarto || ""));
  lines.push("Commune: " + (data.city || ""));
  lines.push("Département: " + (data.dept || ""));
  lines.push("Région: " + (data.region || ""));
  lines.push("X (L2 étendu): " + (data.x || ""));
  lines.push("Y (L2 étendu): " + (data.y || ""));
  lines.push("Latitude: " + (data.lat || ""));
  lines.push("Longitude: " + (data.lon || ""));
  lines.push("Azimuts: " + (data.azPretty || ""));
  return lines.join(" | ");
}

async function fillLocationFromBAN(data){
  // priorité: lat/lon -> reverse
  try {
    if (Number.isFinite(data.latNum) && Number.isFinite(data.lonNum)) {
      const j = await banReverse(data.latNum, data.lonNum);
      const feat = j.features && j.features[0];
      if (feat && feat.properties) {
        const props = feat.properties;
        const banAddr = buildCartoradioAddressFromBAN(props);
        if (!data.addrCarto || !data.addrCarto.trim()) data.addrCarto = banAddr;

        data.city = props.city || data.city;
        const ctx = parseContextDeptRegion(props.context || "");
        data.dept = ctx.dept || data.dept;
        data.region = ctx.region || data.region;
        return;
      }
    }
  } catch(e){}

  // sinon: adresse -> search
  try {
    if (data.addrLine) {
      const j = await banSearch(data.addrLine);
      const feat = j.features && j.features[0];
      if (feat && feat.properties) {
        const props = feat.properties;
        const banAddr = buildCartoradioAddressFromBAN(props);
        if (!data.addrCarto || !data.addrCarto.trim()) data.addrCarto = banAddr;
        data.city = props.city || data.city;
        const ctx = parseContextDeptRegion(props.context || "");
        data.dept = ctx.dept || data.dept;
        data.region = ctx.region || data.region;
        return;
      }
    }
  } catch(e){}
}

function formatDec(n, dec){
  if (!Number.isFinite(n)) return "";
  return n.toFixed(dec);
}

async function parseAndFill(pages, fileName){
  fileName = (fileName || "").toString();
  dbg("parseAndFill() appelé. pages=" + (pages ? pages.length : 0));

  // 1) extraction champs
  const op = extractOperator(pages);
  const dt = extractDate(pages, fileName);
  const sr = extractSiteRef(pages);
  const adr = extractAddressLine(pages);
  const xy = extractLambertXY(pages);
  const ll = extractLatLonWGS(pages);
  const az = extractAzimuts(pages);
  const com = extractCommune(pages);

dbg("op=" + op.value + " (p." + op.page + ")");
dbg("dt=" + dt.value + " (p." + dt.page + ")");
dbg("sr=" + sr.value + " (p." + sr.page + ")");
dbg("adr=" + adr.value + " (p." + adr.page + ")");
dbg("com=" + com.city + " " + com.cp + " (p." + com.page + ")");




  // 2) coord computation
  let latFromLam = NaN, lonFromLam = NaN;
  let latSrc = "";
  let coherenceTxt = "";   // texte affiché dans coord_delta


  // Lambert -> WGS
  if (Number.isFinite(xy.x) && Number.isFinite(xy.y)) {
    try {
      const w = lambertToWgs84(xy.x, xy.y);
      lonFromLam = w.lon;
      latFromLam = w.lat;
    } catch(e){}
  }

  // choisir source lat/lon
  let latNum = NaN, lonNum = NaN;
  if (Number.isFinite(ll.lat) && Number.isFinite(ll.lon)) {
    latNum = ll.lat;
    lonNum = ll.lon;
    latSrc = "Fournies par le DIM";

    if (Number.isFinite(latFromLam) && Number.isFinite(lonFromLam)) {
      const d = haversineMeters(latNum, lonNum, latFromLam, lonFromLam);

      if (d <= 250) {
        coherenceTxt = "Cohérent";
        pillCoord("ok", "X,Y et latitude/longitude opérateur cohérents");
      } else {
        coherenceTxt = "Attention, pas cohérent";
        pillCoord("bad", "Incohérence probable entre X,Y et latitude/longitude opérateur");
      }

      // debug optionnel
      dbg("DEBUG cohérence d=" + Math.round(d) + " m");
    } else {
      // lat/lon présentes mais pas de Lambert exploitable
      coherenceTxt = "Lambert non détecté";
      pillCoord("warn", "Latitude/longitude DIM détectées (Lambert non détecté)");
    }

  } else if (Number.isFinite(latFromLam) && Number.isFinite(lonFromLam)) {
    // pas de lat/lon dans le DIM, mais Lambert -> lat/lon calculées
    latNum = latFromLam;
    lonNum = lonFromLam;

    latSrc = "Calculées approximativement à partir des X,Y Lambert II étendu (± 200 m)";


    coherenceTxt = "L'opérateur n'a pas renseigné de latitude ni de longitude dans le DIM";
    pillCoord("warn", "Lat/Lon calculées depuis Lambert II étendu");

  } else {
    coherenceTxt = "Coordonnées non détectées";
    pillCoord("bad", "Coordonnées non détectées");
  }


  // 3) Localisation via BAN
  const data = {
    operator: op.value,
    date: dt.value,
    siteRef: sr.value,
    addrLine: adr.value,
    addrCarto: adr.value ? adr.value.replace(/,/g,"") : "",
    city: com.city || "",
    dept: "",
    region: "",
    x: Number.isFinite(xy.x) ? formatDec(xy.x, 2).replace(/\.00$/, "") : "",
    y: Number.isFinite(xy.y) ? formatDec(xy.y, 2).replace(/\.00$/, "") : "",

    latNum: latNum,
    lonNum: lonNum,
    lat: Number.isFinite(latNum) ? formatDec(latNum, 7) : "",
    lon: Number.isFinite(lonNum) ? formatDec(lonNum, 7) : "",
    src: latSrc,
    deltaM: coherenceTxt,  // on réutilise le champ UI existant
    azList: az.list,
    azPretty: az.list.length ? az.list.join(" / ") : "",
    azCsv: az.list.length ? az.list.join(";") : ""
  };

  await fillLocationFromBAN(data);
  if (!data.dept) data.dept = deptFromCP(com.cp);


  // 4) Remplir UI
  setVal("doc_operator", data.operator);
  setVal("doc_date", data.date);
  setVal("doc_siteRef", data.siteRef);

  setVal("loc_addrCarto", data.addrCarto);
  
  setVal("loc_dept", data.dept);
  setVal("loc_region", data.region);

  setVal("loc_city", data.city);



  setVal("coord_x", data.x);
  setVal("coord_y", data.y);
  setVal("coord_lat", data.lat);
  setVal("coord_lon", data.lon);
  setVal("coord_latlon", data.lat && data.lon ? (data.lat + ", " + data.lon) : "");
  setVal("coord_lonlat", data.lon && data.lat ? (data.lon + "," + data.lat) : "");
  setVal("coord_src", data.src);
  setVal("coord_delta", data.deltaM);

  setVal("ant_az_pretty", data.azPretty);
  setVal("ant_az_csv", data.azCsv);

  const summary = buildSummary(data);
  setVal("export_summary", summary);

  const exportObj = {
    operateur: data.operator,
    date: data.date,
    reference_site: data.siteRef,
    adresse_cartoradio: data.addrCarto,
    commune: data.city,
    departement: data.dept,
    region: data.region,
    x_lambert2e: data.x,
    y_lambert2e: data.y,
    latitude: data.lat,
    longitude: data.lon,
    latlon_source: data.src,
    coherence_dim_xy_latlon: data.deltaM,
    azimuts: data.azList
  };
  setVal("export_json", JSON.stringify(exportObj));

  // 5) Traçabilité
  setText("traceDoc",
    (op.value ? `Opérateur (p.${op.page}): ${op.snippet}\n` : "") +
    (dt.value ? `Date (p.${dt.page}): ${dt.snippet}\n` : "") +
    (sr.value ? `Référence (p.${sr.page}): ${sr.snippet}\n` : "")
  );

  setText("traceLoc",
    (adr.value ? `Adresse (p.${adr.page}): ${adr.snippet}\n` : "") +
    (data.addrCarto ? `Adresse Cartoradio: ${data.addrCarto}\n` : "") +
    (data.city ? `Commune: ${data.city}\n` : "") +
    (data.dept ? `Département: ${data.dept}\n` : "") +
    (data.region ? `Région: ${data.region}\n` : "")
  );

  const coordTraceLines = [];
  if (xy.pageX) coordTraceLines.push(`X (p.${xy.pageX}): ${xy.snipX}`);
  if (xy.pageY) coordTraceLines.push(`Y (p.${xy.pageY}): ${xy.snipY}`);
  if (ll.pageLat) coordTraceLines.push(`Latitude (p.${ll.pageLat}): ${ll.snipLat}`);
  if (ll.pageLon) coordTraceLines.push(`Longitude (p.${ll.pageLon}): ${ll.snipLon}`);
  setText("traceCoord", coordTraceLines.join("\n"));

  const antTrace = [];
  if (az.list.length) antTrace.push("Azimuts détectés: " + az.list.join(", "));
  if (az.trace) antTrace.push(az.trace);
  setText("traceAnt", antTrace.join("\n"));

  setStatus("Analyse terminée.", "ok");
}

/* =========================================================
   Events
   ========================================================= */
$("btnClear").addEventListener("click", clearAllFields);

$("btnOpenCarto").addEventListener("click", () => {
  window.open("https://www.cartoradio.fr/", "_blank", "noopener");
});

$("selDoc").addEventListener("click", () => selectBlock("blockDoc"));
$("selLoc").addEventListener("click", () => selectBlock("blockLoc"));
$("selCoord").addEventListener("click", () => selectBlock("blockCoord"));
$("selAnt").addEventListener("click", () => selectBlock("blockAnt"));
$("selAll").addEventListener("click", () => selectBlock("blockExport"));

[
  "doc_operator","doc_date","doc_siteRef",
  "loc_addrCarto","loc_city","loc_dept","loc_region",
  "coord_x","coord_y","coord_lat","coord_lon","coord_latlon","coord_lonlat","coord_src","coord_delta",
  "ant_az_pretty","ant_az_csv",
  "export_summary","export_json"
].forEach(fid => {
  const btn = $("copy_" + fid);
  if (btn) btn.addEventListener("click", () => copyFieldValue(fid));
});

$("btnAnalyze").addEventListener("click", async () => {
  dbg("CLICK Analyser");
try {
  await ensurePdfJsModule();
  dbg("PDF.js local OK");
    if (!window.pdfjsLib || typeof window.pdfjsLib.getDocument !== "function") throw new Error("PDF.js incomplet (getDocument absent).");
  dbg("PDF.js getDocument OK");

} catch(e) {
  dbg("PDF.js local KO: " + (e && e.message ? e.message : String(e)));
  setStatus("PDF.js local non chargé : voir Debug.", "err");
  return;
}

  // Vérif libs au clic
if (!window.pdfjsLib || !window.Tesseract || !window.proj4) {
  setStatus("Librairies locales non chargées.", "err");
  return;
}

  const f = $("pdfFile").files && $("pdfFile").files[0] ? $("pdfFile").files[0] : null;
  if (!f) { setStatus("Veuillez sélectionner un PDF DIM.", "err"); return; }

  const maxPages = Math.max(1, Math.min(OCR_MAX_PAGES, Number($("maxPages").value ||  OCR_MAX_PAGES)));

  clearAllFields();
  dbg("---- Nouveau run ----");
  dbg("Fichier: " + f.name);
  dbg("Pages max: " + maxPages);

  setAnalyzeBusy(true);
  setStatus("Chargement du PDF...", "ok");

  try {
    const buf = await f.arrayBuffer();
    dbg("ArrayBuffer OK: " + buf.byteLength + " bytes");

    const pages = await runOcrOnPdf(buf, maxPages);
    dbg("OCR OK: pages extraites = " + pages.length);

    // Affiche tout le texte OCR brut dans Notes
    const notesEl = $("notesOcr");
    if (notesEl) notesEl.textContent = dumpFullOcrText(pages);


    // dump court page 3 si dispo
    const p3 = pages.find(p => p.page === 3);
    if (p3) dbg("Extrait p.3: " + (p3.text || "").slice(0, 200).replace(/\n/g, " | "));

    setStatus("Parsing des informations...", "ok");
    await parseAndFill(pages, f.name);


    dbg("parseAndFill terminé.");
  } catch(e) {
    dbg("ERREUR: " + (e && e.stack ? e.stack : String(e)));
    setStatus("Erreur : " + (e && e.message ? e.message : String(e)), "err");
  } finally {
    setAnalyzeBusy(false);
  }
});


// init
clearAllFields();
</script>
</body>
</html>

