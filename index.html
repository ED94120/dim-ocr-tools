<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Extraction DIM (OCR autonome) - V1</title>

  <style>
    body{font-family:Arial, sans-serif; margin:20px; max-width:1100px}
    h2{margin:0 0 6px 0}
    .small{font-size:12px; color:#444}
    .card{border:1px solid #ddd; border-radius:10px; padding:14px; background:#fff; box-shadow:0 1px 2px rgba(0,0,0,0.04)}
    .cardHeader{display:flex; align-items:center; justify-content:space-between; gap:12px; flex-wrap:wrap}
    .cardTitle{font-weight:bold; font-size:16px}
    .controls{display:flex; gap:10px; flex-wrap:wrap; align-items:center}
    label{font-weight:bold}
    input[type="file"]{padding:6px}
    input[type="number"]{width:90px; padding:6px}
    button{padding:10px 14px; cursor:pointer}
    button:disabled{opacity:0.5; cursor:not-allowed}
    .status{margin-top:10px; font-weight:bold}
    .ok{color:#1b5e20}
    .err{color:#b00020}
    .muted{color:#666; font-size:12px}
    .spacer{height:10px}
    .tools{display:flex; gap:10px; flex-wrap:wrap; align-items:center}
    .grid{display:grid; grid-template-columns: 220px 1fr 110px; gap:10px; align-items:center; margin-top:10px}
    .fieldLabel{font-weight:bold}
    .fieldVal{width:100%; padding:8px; box-sizing:border-box}
    .btnCopy{padding:8px 10px}
    .btnSel{padding:8px 10px}
    details{margin-top:10px}
    summary{cursor:pointer; font-weight:bold}
    .mono{font-family:Consolas, monospace; font-size:12px; white-space:pre-wrap}
    .pill{display:inline-block; padding:4px 10px; border-radius:999px; font-size:12px; font-weight:bold}
    .pillOk{background:#e7f4ea; color:#1b5e20; border:1px solid #b8e0c1}
    .pillWarn{background:#fff4e5; color:#8a4b00; border:1px solid #ffd29a}
    .pillBad{background:#fde8ea; color:#b00020; border:1px solid #f5b3bb}
  </style>

  <!-- PDF.js (render pages) -->
  <!-- on chargera pdf.mjs dans le code ailleurs, via import dynamique -->

  <!-- Tesseract.js (OCR local) -->
  <script src="./libs/tesseract/tesseract.min.js"></script>

  <!-- Proj4js (Lambert II étendu -> WGS84) -->
  <script src="./libs/proj4/proj4.min.js"></script>
</head>

<body>
  <h2>Extraction DIM (OCR autonome) - V1</h2>
  <div class="small">
    Déposez un PDF DIM (même scanné). L’OCR est limité à 10 pages. Les champs extraits sont regroupés par blocs, avec un bouton « Copier » pour chaque valeur.
  </div>

  <div class="card" style="margin-top:14px;">
    <div class="cardHeader">
      <div class="cardTitle">Entrée PDF</div>
      <div class="controls">
        <label for="pdfFile">PDF DIM</label>
        <input id="pdfFile" type="file" accept="application/pdf" />
        <label for="maxPages">Pages max</label>
        <input id="maxPages" type="number" min="1" max="10" value="10" />
        <button id="btnAnalyze" type="button">Analyser</button>
        <button id="btnClear" type="button">Effacer</button>
      </div>
    </div>
    <div id="status" class="status muted">Prêt.</div>
    <div id="progress" class="muted"></div>
    
    <details style="margin-top:10px;">
    <summary>Debug</summary>
    <div class="mono" id="debugLog"></div>
    </details>

  </div>

  <div class="spacer"></div>

  <!-- Bloc 1 : Document -->
  <div class="card">
    <div class="cardHeader">
      <div class="cardTitle">Bloc 1 - Document DIM</div>
      <div class="tools">
        <button id="selDoc" class="btnSel" type="button">Sélectionner le bloc</button>
      </div>
    </div>

    <div class="grid" id="blockDoc">
      <div class="fieldLabel">Opérateur</div>
      <input id="doc_operator" class="fieldVal" readonly />
      <button id="copy_doc_operator" class="btnCopy" type="button">Copier</button>

      <div class="fieldLabel">Date du document</div>
      <input id="doc_date" class="fieldVal" readonly />
      <button id="copy_doc_date" class="btnCopy" type="button">Copier</button>

      <div class="fieldLabel">Référence du site</div>
      <input id="doc_siteRef" class="fieldVal" readonly />
      <button id="copy_doc_siteRef" class="btnCopy" type="button">Copier</button>
    </div>

    <details>
      <summary>Traçabilité (pages et extraits OCR)</summary>
      <div class="mono" id="traceDoc"></div>
    </details>
  </div>

  <div class="spacer"></div>

  <!-- Bloc 2 : Localisation -->
  <div class="card">
    <div class="cardHeader">
      <div class="cardTitle">Bloc 2 - Localisation du site</div>
      <div class="tools">
        <button id="selLoc" class="btnSel" type="button">Sélectionner le bloc</button>
        <button id="btnOpenCarto" type="button">Ouvrir Cartoradio</button>
      </div>
    </div>

    <div class="grid" id="blockLoc">
      <div class="fieldLabel">Adresse (format Cartoradio)</div>
      <input id="loc_addrCarto" class="fieldVal" readonly />
      <button id="copy_loc_addrCarto" class="btnCopy" type="button">Copier</button>

      <div class="fieldLabel">Commune</div>
      <input id="loc_city" class="fieldVal" readonly />
      <button id="copy_loc_city" class="btnCopy" type="button">Copier</button>

      <div class="fieldLabel">Département</div>
      <input id="loc_dept" class="fieldVal" readonly />
      <button id="copy_loc_dept" class="btnCopy" type="button">Copier</button>

      <div class="fieldLabel">Région</div>
      <input id="loc_region" class="fieldVal" readonly />
      <button id="copy_loc_region" class="btnCopy" type="button">Copier</button>
    </div>

    <details>
      <summary>Traçabilité (pages et extraits OCR)</summary>
      <div class="mono" id="traceLoc"></div>
    </details>
  </div>

  <div class="spacer"></div>

  <!-- Bloc 3 : Coordonnées -->
  <div class="card">
    <div class="cardHeader">
      <div class="cardTitle">Bloc 3 - Coordonnées</div>
      <div class="tools">
        <button id="selCoord" class="btnSel" type="button">Sélectionner le bloc</button>
        <span id="coordPill" class="pill pillWarn" style="display:none;"></span>
      </div>
    </div>

    <div class="grid" id="blockCoord">
      <div class="fieldLabel">X Lambert II étendu (m)</div>
      <input id="coord_x" class="fieldVal" readonly />
      <button id="copy_coord_x" class="btnCopy" type="button">Copier</button>

      <div class="fieldLabel">Y Lambert II étendu (m)</div>
      <input id="coord_y" class="fieldVal" readonly />
      <button id="copy_coord_y" class="btnCopy" type="button">Copier</button>

      <div class="fieldLabel">Latitude WGS84 (deg)</div>
      <input id="coord_lat" class="fieldVal" readonly />
      <button id="copy_coord_lat" class="btnCopy" type="button">Copier</button>

      <div class="fieldLabel">Longitude WGS84 (deg)</div>
      <input id="coord_lon" class="fieldVal" readonly />
      <button id="copy_coord_lon" class="btnCopy" type="button">Copier</button>

      <div class="fieldLabel">Copie lat, lon</div>
      <input id="coord_latlon" class="fieldVal" readonly />
      <button id="copy_coord_latlon" class="btnCopy" type="button">Copier</button>

      <div class="fieldLabel">Copie lon,lat (KML)</div>
      <input id="coord_lonlat" class="fieldVal" readonly />
      <button id="copy_coord_lonlat" class="btnCopy" type="button">Copier</button>

      <div class="fieldLabel">Source lat/lon</div>
      <input id="coord_src" class="fieldVal" readonly />
      <button id="copy_coord_src" class="btnCopy" type="button">Copier</button>

      <div class="fieldLabel">Cohérence DIM(X,Y,lat,long)</div>

      <input id="coord_delta" class="fieldVal" readonly />
      <button id="copy_coord_delta" class="btnCopy" type="button">Copier</button>
    </div>

    <details>
      <summary>Traçabilité (pages et extraits OCR)</summary>
      <div class="mono" id="traceCoord"></div>
    </details>
  </div>

  <div class="spacer"></div>

  <!-- Bloc 4 : Antennes -->
  <div class="card">
    <div class="cardHeader">
      <div class="cardTitle">Bloc 4 - Antennes</div>
      <div class="tools">
        <button id="selAnt" class="btnSel" type="button">Sélectionner le bloc</button>
      </div>
    </div>

    <div class="grid" id="blockAnt">
      <div class="fieldLabel">Azimuts (format lisible)</div>
      <input id="ant_az_pretty" class="fieldVal" readonly />
      <button id="copy_ant_az_pretty" class="btnCopy" type="button">Copier</button>

      <div class="fieldLabel">Azimuts (CSV ;)</div>
      <input id="ant_az_csv" class="fieldVal" readonly />
      <button id="copy_ant_az_csv" class="btnCopy" type="button">Copier</button>
    </div>

    <details>
      <summary>Traçabilité (pages et extraits OCR)</summary>
      <div class="mono" id="traceAnt"></div>
    </details>
  </div>

  <div class="spacer"></div>

  <!-- Bloc 5 : Export -->
  <div class="card">
    <div class="cardHeader">
      <div class="cardTitle">Bloc 5 - Export global</div>
      <div class="tools">
        <button id="selAll" class="btnSel" type="button">Sélectionner le résumé</button>
      </div>
    </div>

    <div class="grid" id="blockExport">
      <div class="fieldLabel">Résumé global</div>
      <input id="export_summary" class="fieldVal" readonly />
      <button id="copy_export_summary" class="btnCopy" type="button">Copier</button>

      <div class="fieldLabel">Export JSON (texte)</div>
      <input id="export_json" class="fieldVal" readonly />
      <button id="copy_export_json" class="btnCopy" type="button">Copier</button>
    </div>

    <details>
      <summary>Notes</summary>
      <div class="mono muted" id="notesOcr">
      V1 : extraction champs clés + traçabilité. OCR limité à 10 pages.
      </div>

V1 : extraction champs clés + traçabilité. OCR limité à 10 pages.
      </div>
    </details>
  </div>

<script>

async function ensurePdfJsModule(){
  if (window.pdfjsLib && window.pdfjsLib.getDocument) return window.pdfjsLib;

  const pdfjs = await import("./libs/pdfjs/pdf.mjs");

  // On fabrique un objet pdfjsLib minimal compatible avec ton code existant
  window.pdfjsLib = pdfjs;

  // Worker local en module

window.pdfjsLib.GlobalWorkerOptions.workerPort =
  new Worker("./libs/pdfjs/pdf.worker.mjs", { type: "module" });



  return window.pdfjsLib;
}



"use strict";

window.addEventListener("error", (ev) => {
  try { dbg("JS ERROR: " + (ev.message || ev.error || "Erreur inconnue")); } catch(e) {}
  try { setStatus("Erreur JavaScript : voir Debug.", "err"); } catch(e) {}
});

window.addEventListener("unhandledrejection", (ev) => {
  try { dbg("PROMISE REJECT: " + (ev.reason ? (ev.reason.message || ev.reason) : "rejet")); } catch(e) {}
  try { setStatus("Erreur (Promise) : voir Debug.", "err"); } catch(e) {}
});



/* =========================================================
   Helpers DOM / UI
   ========================================================= */
const $ = (id) => document.getElementById(id);

function setStatus(msg, kind){
  const el = $("status");
  el.className = "status " + (kind === "ok" ? "ok" : (kind === "err" ? "err" : "muted"));
  el.textContent = msg || "";
}

function setProgress(msg){ $("progress").textContent = msg || ""; }

function dbg(msg){
  const el = $("debugLog");
  if (!el) return;
  el.textContent += msg + "\n";
}

function setAnalyzeBusy(isBusy){
  $("btnAnalyze").disabled = !!isBusy;
  $("btnClear").disabled = !!isBusy;
  $("pdfFile").disabled = !!isBusy;
  $("maxPages").disabled = !!isBusy;
}


function setVal(id, v){
  const el = $(id);
  if (!el) return;
  el.value = (v == null) ? "" : String(v);
}
function setText(id, v){
  const el = $(id);
  if (!el) return;
  el.textContent = (v == null) ? "" : String(v);
}

function clearAllFields(){
   setText("debugLog", "");

  [
    "doc_operator","doc_date","doc_siteRef",
    "loc_addrCarto","loc_city","loc_dept","loc_region",
    "coord_x","coord_y","coord_lat","coord_lon","coord_latlon","coord_lonlat","coord_src","coord_delta",
    "ant_az_pretty","ant_az_csv",
    "export_summary","export_json"
  ].forEach(id => setVal(id, ""));

  ["traceDoc","traceLoc","traceCoord","traceAnt"].forEach(id => setText(id, ""));

  $("coordPill").style.display = "none";
  $("coordPill").className = "pill pillWarn";
  $("coordPill").textContent = "";

  setProgress("");
  setStatus("Prêt.", "ok");
}

function dumpFullOcrText(pages){
  return pages
    .map(p => `===== PAGE ${p.page} =====\n${p.text || ""}`)
    .join("\n\n");
}


function selectBlock(blockId){
  const el = $(blockId);
  if (!el) return;

  const text = el.innerText || "";
  const ta = document.createElement("textarea");
  ta.value = text;
  ta.style.position = "fixed";
  ta.style.left = "-9999px";
  ta.style.top = "-9999px";
  document.body.appendChild(ta);
  ta.focus();
  ta.select();
  ta.setSelectionRange(0, ta.value.length);
  document.body.removeChild(ta);

  setStatus("Bloc sélectionné. Faites Ctrl+C.", "ok");
}

/* =========================================================
   Clipboard: copie robuste
   ========================================================= */
async function copyTextRobust(text, selectFallbackEl){
  const t = (text || "").toString();
  if (!t.trim()) return { ok:false, mode:"empty" };

  try {
    if (navigator.clipboard && navigator.clipboard.writeText && window.isSecureContext) {
      await navigator.clipboard.writeText(t);
      return { ok:true, mode:"clipboard" };
    }
  } catch(e){}

  if (selectFallbackEl) {
    selectFallbackEl.focus({preventScroll:true});
    selectFallbackEl.select();
    selectFallbackEl.setSelectionRange(0, selectFallbackEl.value.length);
    return { ok:false, mode:"select" };
  }

  return { ok:false, mode:"fail" };
}

async function copyFieldValue(inputId){
  const el = $(inputId);
  const v = el ? (el.value || "") : "";
  const r = await copyTextRobust(v, el);
  if (r.ok) setStatus("Copié.", "ok");
  else if (r.mode === "select") setStatus("Copie automatique refusée. Valeur sélectionnée : faites Ctrl+C.", "err");
  else setStatus("Rien à copier.", "err");
}

/* =========================================================
   PDF.js configuration
   ========================================================= */
// pdfjsLib.GlobalWorkerOptions.workerSrc =
// "https://cdn.jsdelivr.net/npm/pdfjs-dist@4.10.38/build/pdf.worker.min.js";

/* =========================================================
   Projections : Lambert II étendu (EPSG:27572) -> WGS84 (EPSG:4326)
   ========================================================= */
 //proj4.defs("EPSG:27572",
 // "+proj=lcc +lat_1=46.8 +lat_2=45.89891888888889 +lat_0=46.8 " +
 // "+lon_0=0 +x_0=600000 +y_0=2200000 +a=6378249.2 +b=6356515 " +
 // "+towgs84=-168,-60,320,0,0,0,0 +units=m +no_defs");

let _projInited = false;


window._projInited = window._projInited || false;
if (!window._projInited) {
proj4.defs("EPSG:27572",
  "+proj=lcc +lat_1=46.8 +lat_2=45.89891888888889 +lat_0=46.8 " +
  "+lon_0=0 +x_0=600000 +y_0=2200000 +a=6378249.2 +b=6356515 " +
  "+pm=paris " +
  "+towgs84=-168,-60,320,0,0,0,0 +units=m +no_defs"
);

  window._projInited = true;
}



/* =========================================================
   OCR + parsing
   ========================================================= */

function normSpaces(s){ return (s || "").toString().replace(/\s+/g, " ").trim(); }

function normalizeOcrText(s){
  let t = (s || "").toString();

  // uniformiser espaces
  t = t.replace(/\r/g, "\n");
  t = t.replace(/[ \t]+/g, " ");
  t = t.replace(/\n{3,}/g, "\n\n");

  // symboles degré
  t = t.replace(/º/g, "°");

  // OCR fréquents: 0/O dans les nombres -> correction prudente
  // remplace O par 0 seulement dans des tokens très numériques
  t = t.replace(/([0-9])O(?=[0-9])/g, "$10");
  t = t.replace(/O(?=[0-9])/g, "0");
    // OCR fréquent : "6O°" au lieu de "60°"
  t = t.replace(/([0-9])O(?=°)/g, "$10");
  t = t.replace(/O(?=°)/g, "0");
  

  return t;
}

function findFirstRegex(pages, re){
  for (const p of pages) {
    const m = p.text.match(re);
    if (m) return { page:p.page, match:m };
  }
  return null;
}

function findAllRegex(pages, re){
  const out = [];
  for (const p of pages) {
    let m;
    const r = new RegExp(re.source, re.flags.includes("g") ? re.flags : (re.flags + "g"));
    while ((m = r.exec(p.text)) !== null) {
      out.push({ page:p.page, match:m });
      if (m.index === r.lastIndex) r.lastIndex++;
    }
  }
  return out;
}

function joinedText(pages){
  return pages.map(p => p.text || "").join("\n");
}

function extractOperator(pages){
  const t = joinedText(pages);
  const m = t.match(/\bop[ée]rateur\b\s*[:\-]\s*([^\n]+)/i);
  if (m) return { value: normSpaces(m[1]).toUpperCase(), page: null, snippet: m[0] };
  // fallback marqueurs opérateurs
  if (/\bfree\b/i.test(t)) return { value:"FREE MOBILE", page:null, snippet:"free" };
  if (/\borange\b/i.test(t)) return { value:"ORANGE", page:null, snippet:"orange" };
  if (/\bsfr\b/i.test(t)) return { value:"SFR", page:null, snippet:"sfr" };
  if (/\bbouygues\b/i.test(t)) return { value:"BOUYGUES TELECOM", page:null, snippet:"bouygues" };
  return { value:"", page:null, snippet:"" };
}

function extractDate(pages){
  const t = joinedText(pages);

  // priorité : DATE : 29/08/2023 (ou 29-08-2023)
  const m0 = t.match(/\bdate\b\s*[:\-]\s*(\d{1,2}[\/\-.]\d{1,2}[\/\-.]\d{2,4})/i);
  if (m0) return { value: m0[1], page:null, snippet:m0[0] };

  // fallback : première date plausible
  const m1 = t.match(/(\d{1,2}[\/\-.]\d{1,2}[\/\-.]\d{2,4})/);
  if (m1) return { value: m1[1], page:null, snippet:m1[0] };

  return { value:"", page:null, snippet:"" };
}

function extractSiteRef(pages){
  const t = joinedText(pages);

  // CODE SITE : 59316_002_01 (tolère espaces/underscores)
  const m0 = t.match(/\bcode\s*site\b\s*[:\-]\s*([0-9]{5}[\s_][0-9]{3}[\s_][0-9]{2})/i);
  if (m0) return { value: m0[1].replace(/\s+/g, "_"), page:null, snippet:m0[0] };

  // fallback : motif brut 59316_002_01
  const m1 = t.match(/\b\d{5}_\d{3}_\d{2}\b/);
  if (m1) return { value: m1[0], page:null, snippet:m1[0] };

  return { value:"", page:null, snippet:"" };
}

function extractAddressLine(pages){
  const t = joinedText(pages);

  // ADRESSE DU SITE : 886, rue Roger Salengro
  const m0 = t.match(/\badresse\s*(?:du\s*site)?\b\s*[:\-]\s*([^\n]+)/i);
  if (m0) return { value: normSpaces(m0[1]), page:null, snippet:m0[0] };

  // fallback : ligne contenant CP + commune
  const m1 = t.match(/([0-9]{1,4}\s+[^\n]{3,}\s+\b\d{5}\b\s+[A-ZÀ-ÖØ-Ýa-zà-öø-ÿ'\- ]{3,})/);
  if (m1) return { value: normSpaces(m1[1]), page:null, snippet:m1[0] };

  return { value:"", page:null, snippet:"" };
}

function extractCommune(pages){
  const t = joinedText(pages);

  // COMMUNE : 59263 HOUPLIN ANCOISNE  (ou sans code postal)
  const m0 = t.match(/\bcommune\b\s*[:\-]\s*([^\n]+)/i);
  if (m0) {
    // nettoie "59263 ..." si présent au début
    const v = normSpaces(m0[1]).replace(/^\d{5}\s+/, "");
    return { value: v, page:null, snippet:m0[0] };
  }

  return { value:"", page:null, snippet:"" };
}



function parseNumberLoose(s){
  if (!s) return NaN;
  let t = s.toString();
  t = t.replace(/\s+/g, "");
  t = t.replace(",", ".");
  // garder digits + dot + minus
  t = t.replace(/[^0-9.\-]/g, "");
  const n = Number(t);
  return Number.isFinite(n) ? n : NaN;
}

function extractLambertXY(pages){
  // tolère "X = 647025" etc
  const hitX = findFirstRegex(pages, /\bX\b\s*[:=]\s*([0-9O][0-9O\s]{4,})/i);
  const hitY = findFirstRegex(pages, /\bY\b\s*[:=]\s*([0-9O][0-9O\s]{4,})/i);

  const x = hitX ? parseNumberLoose(hitX.match[1].replace(/O/g,"0")) : NaN;
  const y = hitY ? parseNumberLoose(hitY.match[1].replace(/O/g,"0")) : NaN;

  // plausibilité L2E
  const okX = Number.isFinite(x) && x > 0 && x < 1300000;
  const okY = Number.isFinite(y) && y > 1500000 && y < 3000000;

  return {
    x: okX ? x : NaN,
    y: okY ? y : NaN,
    pageX: hitX ? hitX.page : null,
    pageY: hitY ? hitY.page : null,
    snipX: hitX ? hitX.match[0] : "",
    snipY: hitY ? hitY.match[0] : "",
    rawX: hitX ? hitX.match[1] : "",
    rawY: hitY ? hitY.match[1] : ""
  };
}

function extractLatLonWGS(pages){
  // tolère virgule ou point, "Latitude : 50.57"
  const hitLat = findFirstRegex(pages, /(?:latitude)\s*[:=]\s*([0-9]{1,2}[.,][0-9]{3,})/i);
  const hitLon = findFirstRegex(pages, /(?:longitude)\s*[:=]\s*([0-9]{1,3}[.,][0-9]{3,})/i);

  const lat = hitLat ? parseNumberLoose(hitLat.match[1]) : NaN;
  const lon = hitLon ? parseNumberLoose(hitLon.match[1]) : NaN;

  const okLat = Number.isFinite(lat) && lat > 40 && lat < 52;
  const okLon = Number.isFinite(lon) && lon > -6 && lon < 10;

  return {
    lat: okLat ? lat : NaN,
    lon: okLon ? lon : NaN,
    pageLat: hitLat ? hitLat.page : null,
    pageLon: hitLon ? hitLon.page : null,
    snipLat: hitLat ? hitLat.match[0] : "",
    snipLon: hitLon ? hitLon.match[0] : ""
  };
}

function lambertToWgs84(x, y){
  // proj4 renvoie [lon,lat]
  const out = proj4("EPSG:27572", "EPSG:4326", [x, y]);
  return { lon: out[0], lat: out[1] };
}

function haversineMeters(lat1, lon1, lat2, lon2){
  const R = 6371000.0;
  const toRad = d => d * Math.PI / 180.0;
  const p1 = toRad(lat1), p2 = toRad(lat2);
  const dp = toRad(lat2 - lat1);
  const dl = toRad(lon2 - lon1);
  const a = Math.sin(dp/2)**2 + Math.cos(p1)*Math.cos(p2)*Math.sin(dl/2)**2;
  return 2*R*Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
}

function extractAzimuts(pages){

  /* ================================
     Paramètres (ajustables)
     ================================ */
  const KEY_BEFORE = 2;           // lignes avant mot-clé
  const KEY_AFTER  = 2;           // lignes après mot-clé
  const BUBBLE_MAX_LINES = 4;     // concat 1..4 lignes
  const MIN_DIST = 80;            // séparation circulaire min (anti-tilts / anti-dates)
  const MAX_DIGITS = 3;           // valeurs d'azimut : 1 à 3 chiffres

  // Mots-clés déclencheurs (mode "explicite")
  const KEYWORDS_RE = /\b(azimut|azimuts|az\b|secteur|s1|s2|s3)\b/i;

  // Déclencheurs très forts (S1/S2/S3 explicite)
  const STRONG_S123_RE = /\b(azimuts?\s*\(s1\s*\/\s*s2\s*\/\s*s3\)|s1\s*\/\s*s2\s*\/\s*s3|secteur\s*[0-9]|azimut\s*[0-9])\b/i;

  function norm(s){
    return (s || "")
      .replace(/º/g, "°")
      .replace(/[oO]/g, "0")
      .replace(/\s+/g, " ")
      .trim();
  }

  function circDistMin(a, b){
    const d = Math.abs(a - b) % 360;
    return Math.min(d, 360 - d);
  }

  function distinct3(a,b,c){
    return (a !== b) && (a !== c) && (b !== c);
  }

  function validateTripletLoose(a, b, c){
    // 1..3 digits, 0..359
    if (!Number.isInteger(a) || !Number.isInteger(b) || !Number.isInteger(c)) return false;
    if (a < 0 || a > 359 || b < 0 || b > 359 || c < 0 || c > 359) return false;
    if (!distinct3(a,b,c)) return false;

    // séparation minimale anti-tilts / anti-pages / anti-dates
    if (circDistMin(a,b) < MIN_DIST) return false;
    if (circDistMin(a,c) < MIN_DIST) return false;
    if (circDistMin(b,c) < MIN_DIST) return false;

    return true;
  }

  function makeBubbles(lines, i){
    const start = Math.max(0, i - KEY_BEFORE);
    const end   = Math.min(lines.length - 1, i + KEY_AFTER);

    const local = [];
    for (let k = start; k <= end; k++) local.push(lines[k] || "");

    const bubbles = [];
    for (let a = 0; a < local.length; a++) {
      for (let len = 1; len <= BUBBLE_MAX_LINES; len++) {
        if (a + len > local.length) break;
        const txt = norm(local.slice(a, a + len).join(" "));
        if (txt) bubbles.push(txt);
      }
    }
    return bubbles;
  }

  function digitsOk(nStr){
    return typeof nStr === "string" && nStr.length >= 1 && nStr.length <= MAX_DIGITS;
  }

  function extractAnglesWithSymbol(text){
    // extrait uniquement des angles avec un symbole "degré-like" : ° ou " ou *
    // + accepte aussi les triplets compacts avec "/" si au moins un symbole est présent dans la bulle
    const out = [];

    const t = text;

    // 1) valeurs avec symbole clair ° ou "
    let m;
    const reDeg = /(\d{1,3})\s*([°"])/g;
    while ((m = reDeg.exec(t)) !== null) {
      if (!digitsOk(m[1])) continue;
      const v = Number(m[1]);
      if (Number.isFinite(v) && v >= 0 && v <= 359) out.push({ v, sym: 2 });
    }

    // 2) valeurs suivies de "*" (OCR parfois)
    const reStar = /(\d{1,3})\s*\*/g;
    while ((m = reStar.exec(t)) !== null) {
      if (!digitsOk(m[1])) continue;
      const v = Number(m[1]);
      if (Number.isFinite(v) && v >= 0 && v <= 359) out.push({ v, sym: 1 });
    }

    // 3) triplets compacts avec "/" : on accepte des valeurs NUES uniquement si :
    //    - présence d'au moins un symbole degré-like dans la bulle
    //    - et présence de "/" dans la bulle
    //    Ceci permet de capturer "60/180°/300"" ou "40°/220°/310°"
    if (out.length > 0 && /\//.test(t)) {
      const reBareSlash = /(?:^|[^0-9])(\d{1,3})(?=\s*\/)/g;
      while ((m = reBareSlash.exec(t)) !== null) {
        if (!digitsOk(m[1])) continue;
        const v = Number(m[1]);
        if (Number.isFinite(v) && v >= 0 && v <= 359) out.push({ v, sym: 0 });
      }
      // aussi le dernier terme après "/" s'il est nu, mais uniquement si la chaîne contient déjà un symbole
      const reBareAfterSlash = /\/\s*(\d{1,3})(?=\D|$)/g;
      while ((m = reBareAfterSlash.exec(t)) !== null) {
        if (!digitsOk(m[1])) continue;
        const v = Number(m[1]);
        if (Number.isFinite(v) && v >= 0 && v <= 359) out.push({ v, sym: 0 });
      }
    }

    // dédup
    const uniq = [];
    for (const a of out) if (!uniq.some(u => u.v === a.v)) uniq.push(a);

    return uniq;
  }

  function extractVerticalTripletNearKeyword(lines, i){
    // Liste verticale : on prend uniquement des nombres "purs" 1..3 digits
    // mais seulement si ils ne sont PAS isolés : il faut au moins un voisin numérique (au-dessus ou au-dessous)
    const start = Math.max(0, i - KEY_BEFORE);
    const end   = Math.min(lines.length - 1, i + KEY_AFTER);

    const vals = [];
    for (let j = start; j <= end; j++) {
      const s = (lines[j] || "").trim();
      if (!/^\d{1,3}$/.test(s)) continue;
      if (s.length > MAX_DIGITS) continue;

      const v = Number(s);
      if (!(v >= 0 && v <= 359)) continue;

      const sPrev = (lines[j - 1] || "").trim();
      const sNext = (lines[j + 1] || "").trim();

      const prevOk = /^\d{1,3}$/.test(sPrev) && sPrev.length <= MAX_DIGITS && Number(sPrev) >= 0 && Number(sPrev) <= 359;
      const nextOk = /^\d{1,3}$/.test(sNext) && sNext.length <= MAX_DIGITS && Number(sNext) >= 0 && Number(sNext) <= 359;

      if (prevOk || nextOk) vals.push(v);
    }

    // dédup + tri
    const uniq = [];
    for (const v of vals) if (!uniq.includes(v)) uniq.push(v);
    uniq.sort((a,b)=>a-b);

    // si on a 3 valeurs, on teste le triplet
    if (uniq.length >= 3) {
      // on peut avoir plus de 3, on teste toutes les combinaisons (petit N)
      for (let a = 0; a < uniq.length; a++) {
        for (let b = a + 1; b < uniq.length; b++) {
          for (let c = b + 1; c < uniq.length; c++) {
            const A = uniq[a], B = uniq[b], C = uniq[c];
            if (validateTripletLoose(A,B,C)) return [A,B,C];
          }
        }
      }
    }

    return null;
  }

  function scoreTriplet(a,b,c, symCount, contextText){
    // score simple : priorité symboles + multiples de 10 + présence mot-clé fort
    let s = 0;

    // symboles "degré-like"
    s += 5 * (symCount || 0);

    // multiples de 10
    if (a % 10 === 0) s += 2;
    if (b % 10 === 0) s += 2;
    if (c % 10 === 0) s += 2;

    // multiples de 5
    if (a % 5 === 0) s += 1;
    if (b % 5 === 0) s += 1;
    if (c % 5 === 0) s += 1;

    // proximité métier : S1/S2/S3 explicite
    if (contextText && STRONG_S123_RE.test(contextText)) s += 20;

    // présence "Azimut(s)" classique
    if (contextText && /\bazimut(s)?\b/i.test(contextText)) s += 8;

    // pénalité si "MHz" présent (souvent tableau de fréquences)
    // (pas éliminatoire : on pénalise légèrement)
    if (contextText && /\bMHz\b/i.test(contextText)) s -= 3;

    return s;
  }

  /* ================================
     Collecte des candidats
     ================================ */
  const candidates = [];

  for (const p of pages) {

    const lines = norm(p.text).split("\n").map(s => (s || "").trim());

    for (let i = 0; i < lines.length; i++) {

      const line = lines[i];
      if (!line) continue;
      if (!KEYWORDS_RE.test(line)) continue;

      // Bulles locales
      const bubbles = makeBubbles(lines, i);

      for (const bub of bubbles) {

        if (!bub) continue;

        const angles = extractAnglesWithSymbol(bub);
        const vals = angles.map(x => x.v);
        if (vals.length < 2) continue;

        // combinaisons de triplets dans la bulle
        for (let a = 0; a < vals.length; a++) {
          for (let b = a + 1; b < vals.length; b++) {
            for (let c = b + 1; c < vals.length; c++) {

              const A = vals[a], B = vals[b], C = vals[c];
              if (!validateTripletLoose(A,B,C)) continue;

              // combien de valeurs ont un vrai symbole ° ou "
              let symCount = 0;
              for (const v of [A,B,C]) {
                const meta = angles.find(x => x.v === v);
                if (meta && meta.sym >= 2) symCount++;
                else if (meta && meta.sym === 1) symCount += 0.5; // "*" : demi-qualité
              }

              const tri = [A,B,C].slice().sort((x,y)=>x-y);

              candidates.push({
                page: p.page,
                tri: tri,
                symCount: symCount,
                context: bub,
                score: scoreTriplet(tri[0],tri[1],tri[2], symCount, bub),
                source: "bubble"
              });
            }
          }
        }
      }

      // Liste verticale autour du mot-clé
      const vt = extractVerticalTripletNearKeyword(lines, i);
      if (vt) {
        const tri = vt.slice().sort((x,y)=>x-y);
        candidates.push({
          page: p.page,
          tri: tri,
          symCount: 0,
          context: lines.slice(Math.max(0,i-KEY_BEFORE), Math.min(lines.length, i+KEY_AFTER+1)).join(" "),
          score: scoreTriplet(tri[0],tri[1],tri[2], 0, lines[i]),
          source: "vertical"
        });
      }

      // Cas mono-ligne "Antenne X : Azimut 120°" (robuste)
      // Ici on ne cherche pas un triplet, mais on collecte des valeurs
      // (elles seront assemblées par scoring via d'autres bulles)
      // -> Rien à faire ici, car le triplet est géré au niveau bulle.
    }
  }

  if (!candidates.length) {
    return { list: [], trace: "" };
  }

  // Sélection meilleur candidat
  candidates.sort((x,y) => {
    if (y.score !== x.score) return y.score - x.score;
    // tie-break : plus de symboles
    if (y.symCount !== x.symCount) return y.symCount - x.symCount;
    // tie-break : page plus tôt
    return (x.page || 999) - (y.page || 999);
  });

  const best = candidates[0];

  return {
    list: best.tri,
    trace: [
      `p.${best.page}: ${best.tri[0]}° / ${best.tri[1]}° / ${best.tri[2]}°`,
      `source=${best.source}`,
      `score=${best.score}`,
      best.context ? `contexte=${best.context}` : ""
    ].filter(Boolean).join("\n")
  };
}




/* =========================================================
   BAN (France) : compléter localisation à partir de lat/lon ou adresse
   ========================================================= */
async function banReverse(lat, lon){
  const url = "https://api-adresse.data.gouv.fr/reverse/?" +
              "lat=" + encodeURIComponent(lat) +
              "&lon=" + encodeURIComponent(lon) +
              "&limit=1";
  const r = await fetch(url, { headers: { "Accept":"application/json" } });
  if (!r.ok) throw new Error("BAN reverse HTTP " + r.status);
  return await r.json();
}

async function banSearch(address){
  const url = "https://api-adresse.data.gouv.fr/search/?" +
              "q=" + encodeURIComponent(address) +
              "&limit=1";
  const r = await fetch(url, { headers: { "Accept":"application/json" } });
  if (!r.ok) throw new Error("BAN search HTTP " + r.status);
  return await r.json();
}

function parseContextDeptRegion(contextStr){
  // ex: "59, Nord, Hauts-de-France"
  const parts = (contextStr || "").toString().split(",").map(s => s.trim()).filter(Boolean);
  const dept = parts[1] ? parts[1] : (parts[0] ? parts[0] : "");
  const region = parts[2] ? parts[2] : "";
  return { dept, region };
}

function buildCartoradioAddressFromBAN(props){
  const num = props.housenumber || "";
  const street = props.street || props.name || "";
  const cp = props.postcode || "";
  const city = props.city || "";
  return normSpaces((num ? (num + " ") : "") + street + (cp ? (" " + cp) : "") + (city ? (" " + city) : ""));
}

/* =========================================================
   OCR execution
   ========================================================= */

async function renderPdfPageToCanvas(pdf, pageNumber, scale){
  const page = await pdf.getPage(pageNumber);
  const viewport = page.getViewport({ scale });
  const canvas = document.createElement("canvas");
  const ctx = canvas.getContext("2d", { willReadFrequently: true });
  canvas.width = Math.floor(viewport.width);
  canvas.height = Math.floor(viewport.height);

  await page.render({ canvasContext: ctx, viewport }).promise;
  return canvas;
}


function ocrLogger(m){
  try{
    if (m && m.status === "recognizing text" && typeof m.progress === "number"){
      setProgress("OCR en cours... " + Math.round(100*m.progress) + " %");
    }
  } catch(e){}
}


async function runOcrOnPdf(arrayBuffer, maxPages){
  const loadingTask = pdfjsLib.getDocument({ data: new Uint8Array(arrayBuffer) });

  const pdf = await loadingTask.promise;

  const total = Math.min(pdf.numPages, Math.max(1, Math.min(10, maxPages)));
  setProgress("PDF chargé : " + pdf.numPages + " page(s). OCR sur " + total + " page(s).");

const worker = await Tesseract.createWorker(
  "fra",
  1,
  {
    workerPath: "./libs/tesseract/worker.min.js",
    corePath: "./libs/tesseract/tesseract-core.wasm.js",
    langPath: "./libs/tessdata"
  }
);

// Important : STRING, pas tableau
await worker.loadLanguage("fra");
await worker.initialize("fra");


  const pages = [];
  for (let i = 1; i <= total; i++) {
    setStatus("OCR en cours...", "ok");
    setProgress("Page " + i + " / " + total + " : rendu + OCR...");

    dbg("Page " + i + ": rendu");

    // scale : compromis vitesse/qualité
    const canvas = await renderPdfPageToCanvas(pdf, i, 2.0);

    // OCR
    dbg("Page " + i + ": OCR");

    const { data } = await worker.recognize(canvas);

  
    const text = normalizeOcrText(data && data.text ? data.text : "");
    pages.push({ page:i, text:text });

    // libérer
    canvas.width = 1;
    canvas.height = 1;
  }

  await worker.terminate();
  setProgress("OCR terminé sur " + total + " page(s).");
  return pages;
}

/* =========================================================
   Parsing global -> remplir UI
   ========================================================= */
function pillCoord(kind, msg){
  const el = $("coordPill");
  el.style.display = "inline-block";
  el.className = "pill " + (kind === "ok" ? "pillOk" : (kind === "bad" ? "pillBad" : "pillWarn"));
  el.textContent = msg;
}

function buildSummary(data){
  const lines = [];
  lines.push("Opérateur: " + (data.operator || ""));
  lines.push("Date: " + (data.date || ""));
  lines.push("Référence site: " + (data.siteRef || ""));
  lines.push("Adresse Cartoradio: " + (data.addrCarto || ""));
  lines.push("Commune: " + (data.city || ""));
  lines.push("Département: " + (data.dept || ""));
  lines.push("Région: " + (data.region || ""));
  lines.push("X (L2 étendu): " + (data.x || ""));
  lines.push("Y (L2 étendu): " + (data.y || ""));
  lines.push("Latitude: " + (data.lat || ""));
  lines.push("Longitude: " + (data.lon || ""));
  lines.push("Azimuts: " + (data.azPretty || ""));
  return lines.join(" | ");
}

async function fillLocationFromBAN(data){
  // priorité: lat/lon -> reverse
  try {
    if (Number.isFinite(data.latNum) && Number.isFinite(data.lonNum)) {
      const j = await banReverse(data.latNum, data.lonNum);
      const feat = j.features && j.features[0];
      if (feat && feat.properties) {
        const props = feat.properties;
        data.addrCarto = buildCartoradioAddressFromBAN(props) || data.addrCarto;
        data.city = props.city || data.city;
        const ctx = parseContextDeptRegion(props.context || "");
        data.dept = ctx.dept || data.dept;
        data.region = ctx.region || data.region;
        return;
      }
    }
  } catch(e){}

  // sinon: adresse -> search
  try {
    if (data.addrLine) {
      const j = await banSearch(data.addrLine);
      const feat = j.features && j.features[0];
      if (feat && feat.properties) {
        const props = feat.properties;
        data.addrCarto = buildCartoradioAddressFromBAN(props) || data.addrCarto;
        data.city = props.city || data.city;
        const ctx = parseContextDeptRegion(props.context || "");
        data.dept = ctx.dept || data.dept;
        data.region = ctx.region || data.region;
        return;
      }
    }
  } catch(e){}
}

function formatDec(n, dec){
  if (!Number.isFinite(n)) return "";
  return n.toFixed(dec);
}

async function parseAndFill(pages){

  dbg("parseAndFill() appelé. pages=" + (pages ? pages.length : 0));

  // 1) extraction champs
  const op = extractOperator(pages);
  const dt = extractDate(pages);
  const sr = extractSiteRef(pages);
  const adr = extractAddressLine(pages);
  const xy = extractLambertXY(pages);
  const ll = extractLatLonWGS(pages);
  const az = extractAzimuts(pages);
  const com = extractCommune(pages);

dbg("op=" + op.value + " (p." + op.page + ")");
dbg("dt=" + dt.value + " (p." + dt.page + ")");
dbg("sr=" + sr.value + " (p." + sr.page + ")");
dbg("adr=" + adr.value + " (p." + adr.page + ")");
dbg("com=" + com.value + " (p." + com.page + ")");



  // 2) coord computation
  let latFromLam = NaN, lonFromLam = NaN;
  let latSrc = "";
  let coherenceTxt = "";   // texte affiché dans coord_delta


  // Lambert -> WGS
  if (Number.isFinite(xy.x) && Number.isFinite(xy.y)) {
    try {
      const w = lambertToWgs84(xy.x, xy.y);
      lonFromLam = w.lon;
      latFromLam = w.lat;
    } catch(e){}
  }

  // choisir source lat/lon
  let latNum = NaN, lonNum = NaN;
  if (Number.isFinite(ll.lat) && Number.isFinite(ll.lon)) {
    latNum = ll.lat;
    lonNum = ll.lon;
    latSrc = "Fournies par le DIM";

    if (Number.isFinite(latFromLam) && Number.isFinite(lonFromLam)) {
      const d = haversineMeters(latNum, lonNum, latFromLam, lonFromLam);

      if (d <= 250) {
        coherenceTxt = "Cohérent";
        pillCoord("ok", "X,Y et latitude/longitude opérateur cohérents");
      } else {
        coherenceTxt = "Attention, pas cohérent";
        pillCoord("bad", "Incohérence probable entre X,Y et latitude/longitude opérateur");
      }

      // debug optionnel
      dbg("DEBUG cohérence d=" + Math.round(d) + " m");
    } else {
      // lat/lon présentes mais pas de Lambert exploitable
      coherenceTxt = "Lambert non détecté";
      pillCoord("warn", "Latitude/longitude DIM détectées (Lambert non détecté)");
    }

  } else if (Number.isFinite(latFromLam) && Number.isFinite(lonFromLam)) {
    // pas de lat/lon dans le DIM, mais Lambert -> lat/lon calculées
    latNum = latFromLam;
    lonNum = lonFromLam;
    latSrc = "Calculées depuis Lambert II étendu";

    coherenceTxt = "Pas de lat, lon dans le DIM";
    pillCoord("warn", "Lat/Lon calculées depuis Lambert II étendu");

  } else {
    coherenceTxt = "Coordonnées non détectées";
    pillCoord("bad", "Coordonnées non détectées");
  }


  // 3) Localisation via BAN
  const data = {
    operator: op.value,
    date: dt.value,
    siteRef: sr.value,
    addrLine: adr.value,
    addrCarto: adr.value ? adr.value.replace(/,/g,"") : "",
    city: "",
    dept: "",
    region: "",
    x: Number.isFinite(xy.x) ? Math.round(xy.x).toString() : "",
    y: Number.isFinite(xy.y) ? Math.round(xy.y).toString() : "",
    latNum: latNum,
    lonNum: lonNum,
    lat: Number.isFinite(latNum) ? formatDec(latNum, 7) : "",
    lon: Number.isFinite(lonNum) ? formatDec(lonNum, 7) : "",
    src: latSrc,
    deltaM: coherenceTxt,  // on réutilise le champ UI existant
    azList: az.list,
    azPretty: az.list.length ? az.list.join(" / ") : "",
    azCsv: az.list.length ? az.list.join(";") : ""
  };

  await fillLocationFromBAN(data);

  // 4) Remplir UI
  setVal("doc_operator", data.operator);
  setVal("doc_date", data.date);
  setVal("doc_siteRef", data.siteRef);

  setVal("loc_addrCarto", data.addrCarto);
  
  setVal("loc_dept", data.dept);
  setVal("loc_region", data.region);
 setVal("loc_city", com.value || data.city);



  setVal("coord_x", data.x);
  setVal("coord_y", data.y);
  setVal("coord_lat", data.lat);
  setVal("coord_lon", data.lon);
  setVal("coord_latlon", data.lat && data.lon ? (data.lat + ", " + data.lon) : "");
  setVal("coord_lonlat", data.lon && data.lat ? (data.lon + "," + data.lat) : "");
  setVal("coord_src", data.src);
  setVal("coord_delta", data.deltaM);

  setVal("ant_az_pretty", data.azPretty);
  setVal("ant_az_csv", data.azCsv);

  const summary = buildSummary(data);
  setVal("export_summary", summary);

  const exportObj = {
    operateur: data.operator,
    date: data.date,
    reference_site: data.siteRef,
    adresse_cartoradio: data.addrCarto,
    commune: data.city,
    departement: data.dept,
    region: data.region,
    x_lambert2e: data.x,
    y_lambert2e: data.y,
    latitude: data.lat,
    longitude: data.lon,
    latlon_source: data.src,
    coherence_dim_xy_latlon: data.deltaM,
    azimuts: data.azList
  };
  setVal("export_json", JSON.stringify(exportObj));

  // 5) Traçabilité
  setText("traceDoc",
    (op.value ? `Opérateur (p.${op.page}): ${op.snippet}\n` : "") +
    (dt.value ? `Date (p.${dt.page}): ${dt.snippet}\n` : "") +
    (sr.value ? `Référence (p.${sr.page}): ${sr.snippet}\n` : "")
  );

  setText("traceLoc",
    (adr.value ? `Adresse (p.${adr.page}): ${adr.snippet}\n` : "") +
    (data.addrCarto ? `Adresse Cartoradio: ${data.addrCarto}\n` : "") +
    (data.city ? `Commune: ${data.city}\n` : "") +
    (data.dept ? `Département: ${data.dept}\n` : "") +
    (data.region ? `Région: ${data.region}\n` : "")
  );

  const coordTraceLines = [];
  if (xy.pageX) coordTraceLines.push(`X (p.${xy.pageX}): ${xy.snipX}`);
  if (xy.pageY) coordTraceLines.push(`Y (p.${xy.pageY}): ${xy.snipY}`);
  if (ll.pageLat) coordTraceLines.push(`Latitude (p.${ll.pageLat}): ${ll.snipLat}`);
  if (ll.pageLon) coordTraceLines.push(`Longitude (p.${ll.pageLon}): ${ll.snipLon}`);
  setText("traceCoord", coordTraceLines.join("\n"));

  const antTrace = [];
  if (az.list.length) antTrace.push("Azimuts détectés: " + az.list.join(", "));
  if (az.trace) antTrace.push(az.trace);
  setText("traceAnt", antTrace.join("\n"));

  setStatus("Analyse terminée.", "ok");
}

/* =========================================================
   Events
   ========================================================= */
$("btnClear").addEventListener("click", clearAllFields);

$("btnOpenCarto").addEventListener("click", () => {
  window.open("https://www.cartoradio.fr/", "_blank", "noopener");
});

$("selDoc").addEventListener("click", () => selectBlock("blockDoc"));
$("selLoc").addEventListener("click", () => selectBlock("blockLoc"));
$("selCoord").addEventListener("click", () => selectBlock("blockCoord"));
$("selAnt").addEventListener("click", () => selectBlock("blockAnt"));
$("selAll").addEventListener("click", () => selectBlock("blockExport"));

[
  "doc_operator","doc_date","doc_siteRef",
  "loc_addrCarto","loc_city","loc_dept","loc_region",
  "coord_x","coord_y","coord_lat","coord_lon","coord_latlon","coord_lonlat","coord_src","coord_delta",
  "ant_az_pretty","ant_az_csv",
  "export_summary","export_json"
].forEach(fid => {
  const btn = $("copy_" + fid);
  if (btn) btn.addEventListener("click", () => copyFieldValue(fid));
});

$("btnAnalyze").addEventListener("click", async () => {
  dbg("CLICK Analyser");
try {
  await ensurePdfJsModule();
  dbg("PDF.js local OK");
    if (!window.pdfjsLib || typeof window.pdfjsLib.getDocument !== "function") throw new Error("PDF.js incomplet (getDocument absent).");
  dbg("PDF.js getDocument OK");

} catch(e) {
  dbg("PDF.js local KO: " + (e && e.message ? e.message : String(e)));
  setStatus("PDF.js local non chargé : voir Debug.", "err");
  return;
}

  // Vérif libs au clic
if (!window.pdfjsLib || !window.Tesseract || !window.proj4) {
  setStatus("Librairies locales non chargées.", "err");
  return;
}

  const f = $("pdfFile").files && $("pdfFile").files[0] ? $("pdfFile").files[0] : null;
  if (!f) { setStatus("Veuillez sélectionner un PDF DIM.", "err"); return; }

  const maxPages = Math.max(1, Math.min(10, Number($("maxPages").value || 10)));

  clearAllFields();
  dbg("---- Nouveau run ----");
  dbg("Fichier: " + f.name);
  dbg("Pages max: " + maxPages);

  setAnalyzeBusy(true);
  setStatus("Chargement du PDF...", "ok");

  try {
    const buf = await f.arrayBuffer();
    dbg("ArrayBuffer OK: " + buf.byteLength + " bytes");

    const pages = await runOcrOnPdf(buf, maxPages);
    dbg("OCR OK: pages extraites = " + pages.length);

    // Affiche tout le texte OCR brut dans Notes
    const notesEl = $("notesOcr");
    if (notesEl) notesEl.textContent = dumpFullOcrText(pages);


    // dump court page 3 si dispo
    const p3 = pages.find(p => p.page === 3);
    if (p3) dbg("Extrait p.3: " + (p3.text || "").slice(0, 200).replace(/\n/g, " | "));

    setStatus("Parsing des informations...", "ok");
    await parseAndFill(pages);

    dbg("parseAndFill terminé.");
  } catch(e) {
    dbg("ERREUR: " + (e && e.stack ? e.stack : String(e)));
    setStatus("Erreur : " + (e && e.message ? e.message : String(e)), "err");
  } finally {
    setAnalyzeBusy(false);
  }
});


// init
clearAllFields();
</script>
</body>
</html>


